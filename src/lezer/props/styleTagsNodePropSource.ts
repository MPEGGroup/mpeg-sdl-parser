import type { NodePropSource } from "@lezer/common";
import { styleTags, Tag, tags as t } from "@lezer/highlight";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../parser.terms.ts";

function getStyleTagsNodePropSource(): NodePropSource {
  const mapping: { [selector: string]: Tag | readonly Tag[] } = {};

  // iterate over all TokenTypeId properties and map them to style tags
  // to ensure we don't reference any that don't exist
  Object.entries(TokenTypeId).forEach(([key, value]) => {
    switch (value) {
      case TokenTypeId.int:
        mapping[key] = t.typeName;
        break;
      case TokenTypeId.unsigned:
        mapping[key] = t.typeName;
        break;
      case TokenTypeId.float:
        mapping[key] = t.typeName;
        break;
      case TokenTypeId.bit:
        mapping[key] = t.typeName;
        break;
      case TokenTypeId.Comment:
        mapping[key] = t.comment;
        break;
      case TokenTypeId.Identifier:
        mapping[key] = t.variableName;
        break;
      case TokenTypeId.BinaryLiteral:
        mapping[key] = t.literal;
        break;
      case TokenTypeId.HexadecimalLiteral:
        mapping[key] = t.literal;
        break;
      case TokenTypeId.MultipleCharacterLiteral:
        mapping[key] = t.literal;
        break;
      case TokenTypeId.IntegerLiteral:
        mapping[key] = t.number;
        break;
      case TokenTypeId.DecimalLiteral:
        mapping[key] = t.number;
        break;
      case TokenTypeId.FloatingPointLiteral:
        mapping[key] = t.number;
        break;
      case TokenTypeId.Base64StringLiteral:
        mapping[key] = t.string;
        break;
      case TokenTypeId.UtfStringLiteral:
        mapping[key] = t.string;
        break;
      case TokenTypeId._if:
        mapping[key] = t.controlKeyword;
        break;
      case TokenTypeId._else:
        mapping[key] = t.controlKeyword;
        break;
      case TokenTypeId._switch:
        mapping[key] = t.controlKeyword;
        break;
      case TokenTypeId._case:
        mapping[key] = t.controlKeyword;
        break;
      case TokenTypeId._break:
        mapping[key] = t.controlKeyword;
        break;
      case TokenTypeId._do:
        mapping[key] = t.controlKeyword;
        break;
      case TokenTypeId._while:
        mapping[key] = t.controlKeyword;
        break;
      case TokenTypeId._class:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId._extends:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId._const:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.map:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.utf8string:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.utf8list:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.utfstring:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.utf16string:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.reserved:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.legacy:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.base64string:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.aligned:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.expandable:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.abstract:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.computed:
        mapping[key] = t.keyword;
        break;
      case TokenTypeId.OpenBrace:
        mapping[key] = t.brace;
        break;
      case TokenTypeId.CloseBrace:
        mapping[key] = t.brace;
        break;
      case TokenTypeId.CloseParenthesis:
        mapping[key] = t.paren;
        break;
      case TokenTypeId.OpenParenthesis:
        mapping[key] = t.paren;
        break;
      case TokenTypeId.OpenBracket:
        mapping[key] = t.squareBracket;
        break;
      case TokenTypeId.CloseBracket:
        mapping[key] = t.squareBracket;
        break;
      case TokenTypeId.PostfixIncrement:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.PostfixDecrement:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.UnaryPlus:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.UnaryNegation:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.Multiplication:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.Division:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.Modulus:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.Addition:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.Subtraction:
        mapping[key] = t.arithmeticOperator;
        break;
      case TokenTypeId.RelationalLessThan:
        mapping[key] = t.compareOperator;
        break;
      case TokenTypeId.RelationalLessThanOrEqual:
        mapping[key] = t.compareOperator;
        break;
      case TokenTypeId.RelationalGreaterThan:
        mapping[key] = t.compareOperator;
        break;
      case TokenTypeId.RelationalGreaterThanOrEqual:
        mapping[key] = t.compareOperator;
        break;
      case TokenTypeId.RelationalEqual:
        mapping[key] = t.compareOperator;
        break;
      case TokenTypeId.RelationalNotEqual:
        mapping[key] = t.compareOperator;
        break;
      case TokenTypeId.BitwiseShiftLeft:
        mapping[key] = t.bitwiseOperator;
        break;
      case TokenTypeId.BitwiseShiftRight:
        mapping[key] = t.bitwiseOperator;
        break;
      case TokenTypeId.BitwiseAnd:
        mapping[key] = t.bitwiseOperator;
        break;
      case TokenTypeId.BitwiseOr:
        mapping[key] = t.bitwiseOperator;
        break;
      case TokenTypeId.LogicalAnd:
        mapping[key] = t.logicOperator;
        break;
      case TokenTypeId.LogicalOr:
        mapping[key] = t.logicOperator;
        break;
      case TokenTypeId.lengthof:
        mapping[key] = t.operatorKeyword;
        break;
      case TokenTypeId.RangeOperator:
        mapping[key] = t.operator;
        break;
      case TokenTypeId.Assignment:
        mapping[key] = t.operator;
        break;
      case TokenTypeId.LookAhead:
        mapping[key] = t.operator;
        break;
      case TokenTypeId.Period:
        mapping[key] = t.punctuation;
        break;
      case TokenTypeId.UtfPrefix:
        mapping[key] = t.punctuation;
        break;
      case TokenTypeId.Colon:
        mapping[key] = t.punctuation;
        break;
      case TokenTypeId.Semicolon:
        mapping[key] = t.punctuation;
        break;
      case TokenTypeId.Comma:
        mapping[key] = t.punctuation;
        break;
      case TokenTypeId.SingleQuote:
        mapping[key] = t.punctuation;
        break;
      case TokenTypeId.DoubleQuote:
        mapping[key] = t.punctuation;
        break;
    }
  });

  return styleTags(mapping);
}

export const styleTagsNodePropSource = getStyleTagsNodePropSource();
