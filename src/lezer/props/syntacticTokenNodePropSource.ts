import { NodeProp, type NodePropSource, NodeType } from "@lezer/common";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../parser.terms.ts";

export const syntacticTokenNodeProp = new NodeProp<string>();

export function getSyntacticTokenNodePropSource(): NodePropSource {
  return (type: NodeType) => {
    switch (type.id) {
      case TokenTypeId.CloseBrace:
        return [syntacticTokenNodeProp, "}"];
      case TokenTypeId.aligned:
        return [syntacticTokenNodeProp, "aligned"];
      case TokenTypeId.OpenParenthesis:
        return [syntacticTokenNodeProp, "("];
      case TokenTypeId.CloseParenthesis:
        return [syntacticTokenNodeProp, ")"];
      case TokenTypeId.expandable:
        return [syntacticTokenNodeProp, "expandable"];
      case TokenTypeId.abstract:
        return [syntacticTokenNodeProp, "abstract"];
      case TokenTypeId._class:
        return [syntacticTokenNodeProp, "class"];
      case TokenTypeId.int:
        return [syntacticTokenNodeProp, "int"];
      case TokenTypeId.unsigned:
        return [syntacticTokenNodeProp, "unsigned"];
      case TokenTypeId.float:
        return [syntacticTokenNodeProp, "float"];
      case TokenTypeId.bit:
        return [syntacticTokenNodeProp, "bit"];
      case TokenTypeId.Comma:
        return [syntacticTokenNodeProp, ","];
      case TokenTypeId._extends:
        return [syntacticTokenNodeProp, "extends"];
      case TokenTypeId.Multiplication:
        return [syntacticTokenNodeProp, "*"];
      case TokenTypeId.Division:
        return [syntacticTokenNodeProp, "/"];
      case TokenTypeId.Modulus:
        return [syntacticTokenNodeProp, "%"];
      case TokenTypeId.Addition:
        return [syntacticTokenNodeProp, "+"];
      case TokenTypeId.Subtraction:
        return [syntacticTokenNodeProp, "-"];
      case TokenTypeId.BitwiseShiftLeft:
        return [syntacticTokenNodeProp, "<<"];
      case TokenTypeId.BitwiseShiftRight:
        return [syntacticTokenNodeProp, ">>"];
      case TokenTypeId.RelationalLessThan:
        return [syntacticTokenNodeProp, "<"];
      case TokenTypeId.RelationalLessThanOrEqual:
        return [syntacticTokenNodeProp, "<="];
      case TokenTypeId.RelationalGreaterThan:
        return [syntacticTokenNodeProp, ">"];
      case TokenTypeId.RelationalGreaterThanOrEqual:
        return [syntacticTokenNodeProp, ">="];
      case TokenTypeId.RelationalEqual:
        return [syntacticTokenNodeProp, "=="];
      case TokenTypeId.RelationalNotEqual:
        return [syntacticTokenNodeProp, "!="];
      case TokenTypeId.BitwiseAnd:
        return [syntacticTokenNodeProp, "&"];
      case TokenTypeId.BitwiseOr:
        return [syntacticTokenNodeProp, "|"];
      case TokenTypeId.LogicalAnd:
        return [syntacticTokenNodeProp, "&&"];
      case TokenTypeId.LogicalOr:
        return [syntacticTokenNodeProp, "||"];
      case TokenTypeId.CloseBracket:
        return [syntacticTokenNodeProp, "]"];
      case TokenTypeId.OpenBracket:
        return [syntacticTokenNodeProp, "["];
      case TokenTypeId.ClassMemberAccess:
        return [syntacticTokenNodeProp, "."];
      case TokenTypeId.Period:
        return [syntacticTokenNodeProp, "."];
      case TokenTypeId.PostfixIncrement:
        return [syntacticTokenNodeProp, "++"];
      case TokenTypeId.PostfixDecrement:
        return [syntacticTokenNodeProp, "--"];
      case TokenTypeId.UnaryPlus:
        return [syntacticTokenNodeProp, "+"];
      case TokenTypeId.UnaryNegation:
        return [syntacticTokenNodeProp, "-"];
      case TokenTypeId.lengthof:
        return [syntacticTokenNodeProp, "lengthof"];
      case TokenTypeId.SingleQuote:
        return [syntacticTokenNodeProp, "'"];
      case TokenTypeId.Colon:
        return [syntacticTokenNodeProp, ":"];
      case TokenTypeId.Assignment:
        return [syntacticTokenNodeProp, "="];
      case TokenTypeId.RangeOperator:
        return [syntacticTokenNodeProp, ".."];
      case TokenTypeId.OpenBrace:
        return [syntacticTokenNodeProp, "{"];
      case TokenTypeId._if:
        return [syntacticTokenNodeProp, "if"];
      case TokenTypeId._else:
        return [syntacticTokenNodeProp, "else"];
      case TokenTypeId._switch:
        return [syntacticTokenNodeProp, "switch"];
      case TokenTypeId._case:
        return [syntacticTokenNodeProp, "case"];
      case TokenTypeId._break:
        return [syntacticTokenNodeProp, "break"];
      case TokenTypeId.Semicolon:
        return [syntacticTokenNodeProp, ";"];
      case TokenTypeId._default:
        return [syntacticTokenNodeProp, "default"];
      case TokenTypeId._for:
        return [syntacticTokenNodeProp, "for"];
      case TokenTypeId.computed:
        return [syntacticTokenNodeProp, "computed"];
      case TokenTypeId._const:
        return [syntacticTokenNodeProp, "const"];
      case TokenTypeId._do:
        return [syntacticTokenNodeProp, "do"];
      case TokenTypeId._while:
        return [syntacticTokenNodeProp, "while"];
      case TokenTypeId.reserved:
        return [syntacticTokenNodeProp, "reserved"];
      case TokenTypeId.legacy:
        return [syntacticTokenNodeProp, "legacy"];
      case TokenTypeId.LookAhead:
        return [syntacticTokenNodeProp, "*"];
      case TokenTypeId.base64string:
        return [syntacticTokenNodeProp, "base64string"];
      case TokenTypeId.DoubleQuote:
        return [syntacticTokenNodeProp, '"'];
      case TokenTypeId.utf16string:
        return [syntacticTokenNodeProp, "utf16string"];
      case TokenTypeId.UtfPrefix:
        return [syntacticTokenNodeProp, "u"];
      case TokenTypeId.utf8string:
        return [syntacticTokenNodeProp, "utf8string"];
      case TokenTypeId.utf8list:
        return [syntacticTokenNodeProp, "utf8list"];
      case TokenTypeId.utfstring:
        return [syntacticTokenNodeProp, "utfstring"];
      case TokenTypeId.map:
        return [syntacticTokenNodeProp, "map"];
      case TokenTypeId.AlignmentBitCount8:
        return [syntacticTokenNodeProp, "8"];
      case TokenTypeId.AlignmentBitCount16:
        return [syntacticTokenNodeProp, "16"];
      case TokenTypeId.AlignmentBitCount32:
        return [syntacticTokenNodeProp, "32"];
      case TokenTypeId.AlignmentBitCount64:
        return [syntacticTokenNodeProp, "64"];
      case TokenTypeId.AlignmentBitCount128:
        return [syntacticTokenNodeProp, "128"];
      default:
        return null;
    }
  };
}
