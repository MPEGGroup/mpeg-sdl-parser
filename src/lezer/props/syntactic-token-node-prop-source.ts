import { NodeProp, NodeType } from "@lezer/common";
import { InternalParseError } from "../../parse-error.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../parser.terms.ts";

export const tokenIdToSyntaxStringMapping = new Map<number, string>();

// iterate over all TokenTypeId properties and map them to syntax strings
// to ensure we don't reference any that don't exist
Object.values(TokenTypeId).forEach((value) => {
  switch (value) {
    case TokenTypeId.CloseBrace:
      tokenIdToSyntaxStringMapping.set(value, "}");
      break;
    case TokenTypeId.aligned:
      tokenIdToSyntaxStringMapping.set(value, "aligned");
      break;
    case TokenTypeId.OpenParenthesis:
      tokenIdToSyntaxStringMapping.set(value, "(");
      break;
    case TokenTypeId.CloseParenthesis:
      tokenIdToSyntaxStringMapping.set(value, ")");
      break;
    case TokenTypeId.expandable:
      tokenIdToSyntaxStringMapping.set(value, "expandable");
      break;
    case TokenTypeId.abstract:
      tokenIdToSyntaxStringMapping.set(value, "abstract");
      break;
    case TokenTypeId._class:
      tokenIdToSyntaxStringMapping.set(value, "class");
      break;
    case TokenTypeId.int:
      tokenIdToSyntaxStringMapping.set(value, "int");
      break;
    case TokenTypeId.unsigned:
      tokenIdToSyntaxStringMapping.set(value, "unsigned");
      break;
    case TokenTypeId.float:
      tokenIdToSyntaxStringMapping.set(value, "float");
      break;
    case TokenTypeId.bit:
      tokenIdToSyntaxStringMapping.set(value, "bit");
      break;
    case TokenTypeId.Comma:
      tokenIdToSyntaxStringMapping.set(value, ",");
      break;
    case TokenTypeId._extends:
      tokenIdToSyntaxStringMapping.set(value, "extends");
      break;
    case TokenTypeId.Multiplication:
      tokenIdToSyntaxStringMapping.set(value, "*");
      break;
    case TokenTypeId.Division:
      tokenIdToSyntaxStringMapping.set(value, "/");
      break;
    case TokenTypeId.Modulus:
      tokenIdToSyntaxStringMapping.set(value, "%");
      break;
    case TokenTypeId.Addition:
      tokenIdToSyntaxStringMapping.set(value, "+");
      break;
    case TokenTypeId.Subtraction:
      tokenIdToSyntaxStringMapping.set(value, "-");
      break;
    case TokenTypeId.BitwiseShiftLeft:
      tokenIdToSyntaxStringMapping.set(value, "<<");
      break;
    case TokenTypeId.BitwiseShiftRight:
      tokenIdToSyntaxStringMapping.set(value, ">>");
      break;
    case TokenTypeId.RelationalLessThan:
      tokenIdToSyntaxStringMapping.set(value, "<");
      break;
    case TokenTypeId.RelationalLessThanOrEqual:
      tokenIdToSyntaxStringMapping.set(value, "<=");
      break;
    case TokenTypeId.RelationalGreaterThan:
      tokenIdToSyntaxStringMapping.set(value, ">");
      break;
    case TokenTypeId.RelationalGreaterThanOrEqual:
      tokenIdToSyntaxStringMapping.set(value, ">=");
      break;
    case TokenTypeId.RelationalEqual:
      tokenIdToSyntaxStringMapping.set(value, "==");
      break;
    case TokenTypeId.RelationalNotEqual:
      tokenIdToSyntaxStringMapping.set(value, "!=");
      break;
    case TokenTypeId.BitwiseAnd:
      tokenIdToSyntaxStringMapping.set(value, "&");
      break;
    case TokenTypeId.BitwiseOr:
      tokenIdToSyntaxStringMapping.set(value, "|");
      break;
    case TokenTypeId.LogicalAnd:
      tokenIdToSyntaxStringMapping.set(value, "&&");
      break;
    case TokenTypeId.LogicalOr:
      tokenIdToSyntaxStringMapping.set(value, "||");
      break;
    case TokenTypeId.CloseBracket:
      tokenIdToSyntaxStringMapping.set(value, "]");
      break;
    case TokenTypeId.OpenBracket:
      tokenIdToSyntaxStringMapping.set(value, "[");
      break;
    case TokenTypeId.ClassMemberAccess:
      tokenIdToSyntaxStringMapping.set(value, ".");
      break;
    case TokenTypeId.Period:
      tokenIdToSyntaxStringMapping.set(value, ".");
      break;
    case TokenTypeId.PostfixIncrement:
      tokenIdToSyntaxStringMapping.set(value, "++");
      break;
    case TokenTypeId.PostfixDecrement:
      tokenIdToSyntaxStringMapping.set(value, "--");
      break;
    case TokenTypeId.UnaryPlus:
      tokenIdToSyntaxStringMapping.set(value, "+");
      break;
    case TokenTypeId.UnaryNegation:
      tokenIdToSyntaxStringMapping.set(value, "-");
      break;
    case TokenTypeId.lengthof:
      tokenIdToSyntaxStringMapping.set(value, "lengthof");
      break;
    case TokenTypeId.SingleQuote:
      tokenIdToSyntaxStringMapping.set(value, "'");
      break;
    case TokenTypeId.Colon:
      tokenIdToSyntaxStringMapping.set(value, ":");
      break;
    case TokenTypeId.Assignment:
      tokenIdToSyntaxStringMapping.set(value, "=");
      break;
    case TokenTypeId.RangeOperator:
      tokenIdToSyntaxStringMapping.set(value, "..");
      break;
    case TokenTypeId.OpenBrace:
      tokenIdToSyntaxStringMapping.set(value, "{");
      break;
    case TokenTypeId._if:
      tokenIdToSyntaxStringMapping.set(value, "if");
      break;
    case TokenTypeId._else:
      tokenIdToSyntaxStringMapping.set(value, "else");
      break;
    case TokenTypeId._switch:
      tokenIdToSyntaxStringMapping.set(value, "switch");
      break;
    case TokenTypeId._case:
      tokenIdToSyntaxStringMapping.set(value, "case");
      break;
    case TokenTypeId._break:
      tokenIdToSyntaxStringMapping.set(value, "break");
      break;
    case TokenTypeId.Semicolon:
      tokenIdToSyntaxStringMapping.set(value, ";");
      break;
    case TokenTypeId._default:
      tokenIdToSyntaxStringMapping.set(value, "default");
      break;
    case TokenTypeId._for:
      tokenIdToSyntaxStringMapping.set(value, "for");
      break;
    case TokenTypeId.computed:
      tokenIdToSyntaxStringMapping.set(value, "computed");
      break;
    case TokenTypeId._const:
      tokenIdToSyntaxStringMapping.set(value, "const");
      break;
    case TokenTypeId._do:
      tokenIdToSyntaxStringMapping.set(value, "do");
      break;
    case TokenTypeId._while:
      tokenIdToSyntaxStringMapping.set(value, "while");
      break;
    case TokenTypeId.reserved:
      tokenIdToSyntaxStringMapping.set(value, "reserved");
      break;
    case TokenTypeId.legacy:
      tokenIdToSyntaxStringMapping.set(value, "legacy");
      break;
    case TokenTypeId.LookAhead:
      tokenIdToSyntaxStringMapping.set(value, "*");
      break;
    case TokenTypeId.base64string:
      tokenIdToSyntaxStringMapping.set(value, "base64string");
      break;
    case TokenTypeId.DoubleQuote:
      tokenIdToSyntaxStringMapping.set(value, '"');
      break;
    case TokenTypeId.utf16string:
      tokenIdToSyntaxStringMapping.set(value, "utf16string");
      break;
    case TokenTypeId.UtfPrefix:
      tokenIdToSyntaxStringMapping.set(value, "u");
      break;
    case TokenTypeId.utf8string:
      tokenIdToSyntaxStringMapping.set(value, "utf8string");
      break;
    case TokenTypeId.utf8list:
      tokenIdToSyntaxStringMapping.set(value, "utf8list");
      break;
    case TokenTypeId.utfstring:
      tokenIdToSyntaxStringMapping.set(value, "utfstring");
      break;
    case TokenTypeId.map:
      tokenIdToSyntaxStringMapping.set(value, "map");
      break;
    case TokenTypeId.AlignmentBitCount8:
      tokenIdToSyntaxStringMapping.set(value, "8");
      break;
    case TokenTypeId.AlignmentBitCount16:
      tokenIdToSyntaxStringMapping.set(value, "16");
      break;
    case TokenTypeId.AlignmentBitCount32:
      tokenIdToSyntaxStringMapping.set(value, "32");
      break;
    case TokenTypeId.AlignmentBitCount64:
      tokenIdToSyntaxStringMapping.set(value, "64");
      break;
    case TokenTypeId.AlignmentBitCount128:
      tokenIdToSyntaxStringMapping.set(value, "128");
      break;
    case TokenTypeId.Whitespace:
    case TokenTypeId.Comment:
    case TokenTypeId.Specification:
    case TokenTypeId.ClassDeclaration:
    case TokenTypeId.CompoundStatement:
    case TokenTypeId.IfStatement:
    case TokenTypeId.SwitchStatement:
    case TokenTypeId.CaseClause:
    case TokenTypeId.DefaultClause:
    case TokenTypeId.WhileStatement:
    case TokenTypeId.MapDeclaration:
    case TokenTypeId.AlignedModifier:
    case TokenTypeId.ExpandableModifier:
    case TokenTypeId.ParameterList:
    case TokenTypeId.Parameter:
    case TokenTypeId.ElementaryType:
    case TokenTypeId.ExtendsModifier:
    case TokenTypeId.ParameterValueList:
    case TokenTypeId.LengthofExpression:
    case TokenTypeId.BitModifier:
    case TokenTypeId.ExtendedClassIdRange:
    case TokenTypeId.ClassId:
    case TokenTypeId.ClassIdRange:
    case TokenTypeId.ForStatement:
    case TokenTypeId.AssignmentExpression:
    case TokenTypeId.ComputedElementaryTypeDefinition:
    case TokenTypeId.DoStatement:
    case TokenTypeId.ExpressionStatement:
    case TokenTypeId.ElementaryTypeDefinition:
    case TokenTypeId.MapDefinition:
    case TokenTypeId.ClassDefinition:
    case TokenTypeId.StringDefinition:
    case TokenTypeId.Base64StringLiteral:
    case TokenTypeId.UtfStringLiteralCharacters:
    case TokenTypeId.ArrayDefinition:
    case TokenTypeId.ImplicitArrayDimension:
    case TokenTypeId.ExplicitArrayDimension:
    case TokenTypeId.PartialArrayDimension:
    case TokenTypeId.ComputedArrayDefinition:
    case TokenTypeId.MapEntry:
    case TokenTypeId.AggregateOutputValue:
    case TokenTypeId.ElementaryTypeOutputValue:
    case TokenTypeId.BinaryExpression:
    case TokenTypeId.UnaryExpression:
    case TokenTypeId.ArrayElementAccess:
    case TokenTypeId.LengthAttribute:
    case TokenTypeId.Identifier:
    case TokenTypeId.IntegerLiteral:
    case TokenTypeId.BinaryLiteral:
    case TokenTypeId.HexadecimalLiteral:
    case TokenTypeId.DecimalLiteral:
    case TokenTypeId.FloatingPointLiteral:
    case TokenTypeId.MultipleCharacterLiteral:
    case TokenTypeId.MultipleCharacterLiteralCharacters:
    case TokenTypeId.Base64StringLiteralCharacters:
    case TokenTypeId.UtfStringLiteral:
      break;
    default: {
      const exhaustiveCheck: never = value;
      throw new InternalParseError(
        "Unreachable code reached, tokenTypeId == " + exhaustiveCheck,
      );
    }
  }
});

export const syntacticTokenNodeProp = new NodeProp<string>();
export const syntacticTokenNodePropSource = syntacticTokenNodeProp.add(
  (type: NodeType) => tokenIdToSyntaxStringMapping.get(type.id),
);
