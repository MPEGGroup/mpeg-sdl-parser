import { LRParser as LezerParser } from "@lezer/lr";
import { Text } from "@codemirror/state";
import { type Input } from "@lezer/common";
import { debugEnabled } from "../util/logger.ts";
import { getContextTracker } from "./context-tracker.ts";
import { styleTagsNodePropSource } from "./props/style-tags-node-prop-source.ts";
import { foldNodePropSource } from "./props/fold-node-prop-source.ts";
import { primitiveNodePropSource } from "./props/primitive-node-prop-source.ts";
import { syntacticTokenNodePropSource } from "./props/syntactic-token-node-prop-source.ts";
import { createParseErrorFromTextAndPosition } from "./create-parse-error-from-text-and-position.ts";

// Generated by Lezer from the SDL grammar
import { parser } from "./parser.ts";

let lenientSdlParser: LezerParser | undefined;
let strictSdlParser: LezerParser | undefined;

/**
 * Create an in memory lenient Lezer based parser using the SDL grammar and store it as a "singleton".
 */
export function createLenientSdlParser(): LezerParser {
  if (!lenientSdlParser) {
    if (debugEnabled) {
      lenientSdlParser = parser.configure({
        contextTracker: getContextTracker(parser),
      });
    } else {
      lenientSdlParser = parser;
    }

    // Configure the parser with custom node properties
    lenientSdlParser = lenientSdlParser.configure({
      props: [
        foldNodePropSource,
        primitiveNodePropSource,
        styleTagsNodePropSource,
        syntacticTokenNodePropSource,
      ],
    });
  }

  return lenientSdlParser;
}

/**
 * Create an in memory strict Lezer based parser using the SDL grammar and store it as a "singleton".
 */
export function createStrictSdlParser(): LezerParser {
  if (!strictSdlParser) {
    strictSdlParser = createLenientSdlParser().configure({
      strict: true,
    });

    // Wrap the parser's parse method to catch errors and wrap them in ParseError
    const originalParseFunc = strictSdlParser.parse.bind(strictSdlParser);

    strictSdlParser.parse = (input: Input | string, ...args) => {
      try {
        return originalParseFunc(input, ...args);
      } catch (err) {
        // parse position out of error message which takes the form "No parse at 0"
        const errorMessage = (err as Error).message;
        const match = errorMessage.match(/No parse at (\d+)/);
        let position = 0;
        if (match) {
          const parsed = parseInt(match[1], 10);
          position = isNaN(parsed) ? 0 : parsed;
        }

        let inputText: string;

        if (typeof input === "string") {
          inputText = input;
        } else {
          inputText = input.read(0, input.length);
        }

        const text = Text.of(
          inputText.split("\n"),
        );

        throw createParseErrorFromTextAndPosition(text, position);
      }
    };
  }

  return strictSdlParser;
}
