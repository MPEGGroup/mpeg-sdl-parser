import { HierarchicalSearch } from "./HierarchicalMap.ts";
import { createLenientSdlParser } from "../lezer/createSdlParser.ts";
import { alignedModifierRules } from "./rules/alignedModifierRules.ts";
import { parameterValueListRules } from "./rules/parameterValueListRules.ts";
import { specificationRules } from "./rules/specificationRules.ts";
import { stringDefinitionRules } from "./rules/stringDefinitionRules.ts";
import { utfStringLiteralRules } from "./rules/utfStringLiteralRules.ts";
import { whileStatementRules } from "./rules/whileStatementRules.ts";
import { computedElementaryTypeRules } from "./rules/computedElementaryTypeRules.ts";
import { elementaryTypeRules } from "./rules/elementaryTypeRules.ts";
import { compoundStatementRules } from "./rules/compoundStatementRules.ts";
import { ifStatementRules } from "./rules/ifStatementRules.ts";
import { forStatementRules } from "./rules/forStatementRules.ts";
import { switchStatementRules } from "./rules/switchStatementRules.ts";
import { caseClauseRules } from "./rules/caseClauseRules.ts";
import { defaultClauseRules } from "./rules/defaultClauseRules.ts";
import { classDeclarationRules } from "./rules/classDeclarationRules.ts";
import { expandableModifierRules } from "./rules/expandableModifierRules.ts";
import { classDefinitionRules } from "./rules/classDefinitionRules.ts";
import { assignmentExpressionRules } from "./rules/assignmentExpressionRules.ts";
import { doStatementRules } from "./rules/doStatementRules.ts";
import { elementaryTypeDefinitionRules } from "./rules/elementaryTypeDefinitionRules.ts";
import { lengthAttributeRules } from "./rules/lengthAttributeRules.ts";
import { extendsModifierRules } from "./rules/extendsModifierRules.ts";
import { parameterListRules } from "./rules/parameterListRules.ts";
import { parameterRules } from "./rules/parameterRules.ts";
import { binaryExpressionRules } from "./rules/binaryExpressionRules.ts";
import { unaryExpressionRules } from "./rules/unaryExpressionRules.ts";
import { arrayElementAccessRules } from "./rules/arrayElementAccessRules.ts";
import { classMemberAccessRules } from "./rules/classMemberAccessRules.ts";
import { lengthofExpressionRules } from "./rules/lengthofExpressionRules.ts";
import { bitModifierRules } from "./rules/bitModifierRules.ts";
import { extendedClassIdRangeRules } from "./rules/extendedClassIdRangeRules.ts";
import { classIdRules } from "./rules/classIdRules.ts";
import { classIdRangeRules } from "./rules/classIdRangeRules.ts";
import { expressionStatementRules } from "./rules/expressionStatementRules.ts";
import { mapDefinitionRules } from "./rules/mapDefinitionRules.ts";
import { arrayDefinitionRules } from "./rules/arrayDefinitionRules.ts";
import { implicitArrayDimensionRules } from "./rules/implicitArrayDimensionRules.ts";
import { explicitArrayDimensionRules } from "./rules/explicitArrayDimensionRules.ts";
import { partialArrayDimensionRules } from "./rules/partialArrayDimensionRules.ts";
import { computedArrayDefinitionRules } from "./rules/computedArrayDefinitionRules.ts";
import { mapDeclarationRules } from "./rules/mapDeclarationRules.ts";
import { mapEntryRules } from "./rules/mapEntryRules.ts";
import { aggregateOutputValueRules } from "./rules/aggregateOutputValueRules.ts";
import { elementaryTypeOutputValueRules } from "./rules/elementaryTypeOutputValueRules.ts";
import getLogger from "../util/logger.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../lezer/parser.terms.ts";

const logger = getLogger("getExpectedTokenTypes");

const lenientSdlParser = createLenientSdlParser();

/**
 * A map from parent token type ID to a HierarchicalSearch of previous sibling token type IDs to expected token type IDs.
 */
export const completionRulesByParentMap: Map<
  number,
  HierarchicalSearch<number[]>
> = new Map();

type CompletionRule = {
  previous: number | number[];
  expected: number | number[];
};

function addRulesForParent(
  parentTokenId: number,
  rules: CompletionRule | CompletionRule[],
) {
  if (completionRulesByParentMap.has(parentTokenId)) {
    throw new Error(
      `Completion rules for parent ${parentTokenId} already exist`,
    );
  }

  if (!Array.isArray(rules)) {
    rules = [rules];
  }

  if (rules.length === 0) {
    logger.warn(
      `No completion rules provided for parent token ${
        lenientSdlParser.nodeSet.types[parentTokenId].name
      }`,
    );
    return;
  }

  const hierarchicalSearch = new HierarchicalSearch<number[]>();

  for (const rule of rules) {
    const previousTokens = Array.isArray(rule.previous)
      ? rule.previous
      : [rule.previous];
    const expectedTokens = Array.isArray(rule.expected)
      ? rule.expected
      : [rule.expected];

    hierarchicalSearch.set(previousTokens, expectedTokens);
  }

  completionRulesByParentMap.set(parentTokenId, hierarchicalSearch);

  logger.debug(
    `Added completion rules for parent token ${
      lenientSdlParser.nodeSet.types[parentTokenId].name
    }`,
  );
}

addRulesForParent(TokenTypeId.AlignedModifier, alignedModifierRules);
addRulesForParent(
  TokenTypeId.ComputedElementaryTypeDefinition,
  computedElementaryTypeRules,
);
addRulesForParent(TokenTypeId.ParameterValueList, parameterValueListRules);
addRulesForParent(TokenTypeId.Specification, specificationRules);
addRulesForParent(TokenTypeId.StringDefinition, stringDefinitionRules);
addRulesForParent(TokenTypeId.UtfStringLiteral, utfStringLiteralRules);
addRulesForParent(TokenTypeId.WhileStatement, whileStatementRules);
addRulesForParent(TokenTypeId.ElementaryType, elementaryTypeRules);
addRulesForParent(TokenTypeId.CompoundStatement, compoundStatementRules);
addRulesForParent(TokenTypeId.IfStatement, ifStatementRules);
addRulesForParent(TokenTypeId.ForStatement, forStatementRules);
addRulesForParent(TokenTypeId.SwitchStatement, switchStatementRules);
addRulesForParent(TokenTypeId.CaseClause, caseClauseRules);
addRulesForParent(TokenTypeId.DefaultClause, defaultClauseRules);
addRulesForParent(TokenTypeId.ClassDeclaration, classDeclarationRules);
addRulesForParent(TokenTypeId.ExpandableModifier, expandableModifierRules);
addRulesForParent(TokenTypeId.ClassDefinition, classDefinitionRules);
addRulesForParent(TokenTypeId.AssignmentExpression, assignmentExpressionRules);
addRulesForParent(TokenTypeId.DoStatement, doStatementRules);
addRulesForParent(
  TokenTypeId.ElementaryTypeDefinition,
  elementaryTypeDefinitionRules,
);
addRulesForParent(TokenTypeId.LengthAttribute, lengthAttributeRules);
addRulesForParent(TokenTypeId.ExtendsModifier, extendsModifierRules);
addRulesForParent(TokenTypeId.ParameterList, parameterListRules);
addRulesForParent(TokenTypeId.Parameter, parameterRules);
addRulesForParent(TokenTypeId.BinaryExpression, binaryExpressionRules);
addRulesForParent(TokenTypeId.UnaryExpression, unaryExpressionRules);
addRulesForParent(TokenTypeId.ArrayElementAccess, arrayElementAccessRules);
addRulesForParent(TokenTypeId.ClassMemberAccess, classMemberAccessRules);
addRulesForParent(TokenTypeId.LengthofExpression, lengthofExpressionRules);
addRulesForParent(TokenTypeId.BitModifier, bitModifierRules);
addRulesForParent(TokenTypeId.ExtendedClassIdRange, extendedClassIdRangeRules);
addRulesForParent(TokenTypeId.ClassId, classIdRules);
addRulesForParent(TokenTypeId.ClassIdRange, classIdRangeRules);
addRulesForParent(TokenTypeId.ExpressionStatement, expressionStatementRules);
addRulesForParent(TokenTypeId.MapDefinition, mapDefinitionRules);
addRulesForParent(TokenTypeId.ArrayDefinition, arrayDefinitionRules);
addRulesForParent(
  TokenTypeId.ImplicitArrayDimension,
  implicitArrayDimensionRules,
);
addRulesForParent(
  TokenTypeId.ExplicitArrayDimension,
  explicitArrayDimensionRules,
);
addRulesForParent(
  TokenTypeId.PartialArrayDimension,
  partialArrayDimensionRules,
);
addRulesForParent(
  TokenTypeId.ComputedArrayDefinition,
  computedArrayDefinitionRules,
);
addRulesForParent(TokenTypeId.MapDeclaration, mapDeclarationRules);
addRulesForParent(TokenTypeId.MapEntry, mapEntryRules);
addRulesForParent(TokenTypeId.AggregateOutputValue, aggregateOutputValueRules);
addRulesForParent(
  TokenTypeId.ElementaryTypeOutputValue,
  elementaryTypeOutputValueRules,
);
