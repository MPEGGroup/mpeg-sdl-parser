import { HierarchicalSearch } from "./HierarchicalMap.ts";
import { alignedModifierRules } from "./rules/alignedModifierRules.ts";
import { parameterValueListRules } from "./rules/parameterValueListRules.ts";
import { specificationRules } from "./rules/specificationRules.ts";
import { stringDefinitionRules } from "./rules/stringDefinitionRules.ts";
import { utfStringLiteralRules } from "./rules/utfStringLiteralRules.ts";
import { whileStatementRules } from "./rules/whileStatementRules.ts";
import { computedElementaryTypeRules } from "./rules/computedElementaryTypeRules.ts";
import { elementaryTypeRules } from "./rules/elementaryTypeRules.ts";
import { compoundStatementRules } from "./rules/compoundStatementRules.ts";
import { ifStatementRules } from "./rules/ifStatementRules.ts";
import { forStatementRules } from "./rules/forStatementRules.ts";
import { switchStatementRules } from "./rules/switchStatementRules.ts";
import { caseClauseRules } from "./rules/caseClauseRules.ts";
import { defaultClauseRules } from "./rules/defaultClauseRules.ts";
import { classDeclarationRules } from "./rules/classDeclarationRules.ts";
import { expandableModifierRules } from "./rules/expandableModifierRules.ts";
import { classDefinitionRules } from "./rules/classDefinitionRules.ts";
import { assignmentExpressionRules } from "./rules/assignmentExpressionRules.ts";
import { doStatementRules } from "./rules/doStatementRules.ts";
import { elementaryTypeDefinitionRules } from "./rules/elementaryTypeDefinitionRules.ts";
import { lengthAttributeRules } from "./rules/lengthAttributeRules.ts";
import { extendsModifierRules } from "./rules/extendsModifierRules.ts";
import { parameterListRules } from "./rules/parameterListRules.ts";
import { parameterRules } from "./rules/parameterRules.ts";
import { binaryExpressionRules } from "./rules/binaryExpressionRules.ts";
import { unaryExpressionRules } from "./rules/unaryExpressionRules.ts";
import { arrayElementAccessRules } from "./rules/arrayElementAccessRules.ts";
import { classMemberAccessRules } from "./rules/classMemberAccessRules.ts";
import { lengthofExpressionRules } from "./rules/lengthofExpressionRules.ts";
import { bitModifierRules } from "./rules/bitModifierRules.ts";
import { extendedClassIdRangeRules } from "./rules/extendedClassIdRangeRules.ts";
import { classIdRules } from "./rules/classIdRules.ts";
import { classIdRangeRules } from "./rules/classIdRangeRules.ts";
import { expressionStatementRules } from "./rules/expressionStatementRules.ts";
import { mapDefinitionRules } from "./rules/mapDefinitionRules.ts";
import { arrayDefinitionRules } from "./rules/arrayDefinitionRules.ts";
import { implicitArrayDimensionRules } from "./rules/implicitArrayDimensionRules.ts";
import { explicitArrayDimensionRules } from "./rules/explicitArrayDimensionRules.ts";
import { partialArrayDimensionRules } from "./rules/partialArrayDimensionRules.ts";
import { computedArrayDefinitionRules } from "./rules/computedArrayDefinitionRules.ts";
import { mapDeclarationRules } from "./rules/mapDeclarationRules.ts";
import { mapEntryRules } from "./rules/mapEntryRules.ts";
import { aggregateOutputValueRules } from "./rules/aggregateOutputValueRules.ts";
import { elementaryTypeOutputValueRules } from "./rules/elementaryTypeOutputValueRules.ts";

import getLogger from "../util/logger.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../lezer/parser.terms.ts";

const logger = getLogger("completionRules");

/**
 * A map from parent token type ID to a HierarchicalSearch of previous sibling token type IDs to expected token type IDs.
 */
export const completionRulesByParentMap: Map<
  number,
  HierarchicalSearch<number[]>
> = new Map();

type CompletionRule = {
  previous: number | number[];
  expected: number | number[];
};

function addRulesForParent(
  parentTokenId: number,
  rules: CompletionRule | CompletionRule[],
) {
  if (completionRulesByParentMap.has(parentTokenId)) {
    throw new Error(
      `Completion rules for parent ${parentTokenId} already exist`,
    );
  }

  if (!Array.isArray(rules)) {
    rules = [rules];
  }

  if (rules.length === 0) {
    logger.warn(
      `No completion rules provided for parent token ID ${parentTokenId}`,
    );
    return;
  }

  const hierarchicalSearch = new HierarchicalSearch<number[]>();

  for (const rule of rules) {
    const previousTokens = Array.isArray(rule.previous)
      ? rule.previous
      : [rule.previous];
    const expectedTokens = Array.isArray(rule.expected)
      ? rule.expected
      : [rule.expected];

    hierarchicalSearch.set(previousTokens, expectedTokens);
  }

  completionRulesByParentMap.set(parentTokenId, hierarchicalSearch);

  logger.debug(
    `Added completion rules for parent token ID ${parentTokenId}`,
  );
}

/**
 * Validate that all TokenTypeIds have completion rules defined, except for those that are intentionally excluded.
 */
Object.values(TokenTypeId).forEach((tokenTypeId) => {
  switch (tokenTypeId) {
    case TokenTypeId.AlignedModifier:
      addRulesForParent(TokenTypeId.AlignedModifier, alignedModifierRules);
      break;
    case TokenTypeId.AggregateOutputValue:
      addRulesForParent(
        TokenTypeId.AggregateOutputValue,
        aggregateOutputValueRules,
      );
      break;
    case TokenTypeId.ArrayDefinition:
      addRulesForParent(TokenTypeId.ArrayDefinition, arrayDefinitionRules);
      break;
    case TokenTypeId.AssignmentExpression:
      addRulesForParent(
        TokenTypeId.AssignmentExpression,
        assignmentExpressionRules,
      );
      break;
    case TokenTypeId.ArrayElementAccess:
      addRulesForParent(
        TokenTypeId.ArrayElementAccess,
        arrayElementAccessRules,
      );
      break;
    case TokenTypeId.BinaryExpression:
      addRulesForParent(TokenTypeId.BinaryExpression, binaryExpressionRules);
      break;
    case TokenTypeId.BitModifier:
      addRulesForParent(TokenTypeId.BitModifier, bitModifierRules);
      break;
    case TokenTypeId.CaseClause:
      addRulesForParent(TokenTypeId.CaseClause, caseClauseRules);
      break;
    case TokenTypeId.ClassDefinition:
      addRulesForParent(TokenTypeId.ClassDefinition, classDefinitionRules);
      break;
    case TokenTypeId.ClassDeclaration:
      addRulesForParent(TokenTypeId.ClassDeclaration, classDeclarationRules);
      break;
    case TokenTypeId.ClassId:
      addRulesForParent(TokenTypeId.ClassId, classIdRules);
      break;
    case TokenTypeId.ClassIdRange:
      addRulesForParent(TokenTypeId.ClassIdRange, classIdRangeRules);
      break;
    case TokenTypeId.ClassMemberAccess:
      addRulesForParent(TokenTypeId.ClassMemberAccess, classMemberAccessRules);
      break;
    case TokenTypeId.CompoundStatement:
      addRulesForParent(TokenTypeId.CompoundStatement, compoundStatementRules);
      break;
    case TokenTypeId.ComputedArrayDefinition:
      addRulesForParent(
        TokenTypeId.ComputedArrayDefinition,
        computedArrayDefinitionRules,
      );
      break;
    case TokenTypeId.ComputedElementaryTypeDefinition:
      addRulesForParent(
        TokenTypeId.ComputedElementaryTypeDefinition,
        computedElementaryTypeRules,
      );
      break;
    case TokenTypeId.DefaultClause:
      addRulesForParent(TokenTypeId.DefaultClause, defaultClauseRules);
      break;
    case TokenTypeId.DoStatement:
      addRulesForParent(TokenTypeId.DoStatement, doStatementRules);
      break;
    case TokenTypeId.ElementaryType:
      addRulesForParent(TokenTypeId.ElementaryType, elementaryTypeRules);
      break;
    case TokenTypeId.ElementaryTypeDefinition:
      addRulesForParent(
        TokenTypeId.ElementaryTypeDefinition,
        elementaryTypeDefinitionRules,
      );
      break;
    case TokenTypeId.ElementaryTypeOutputValue:
      addRulesForParent(
        TokenTypeId.ElementaryTypeOutputValue,
        elementaryTypeOutputValueRules,
      );
      break;
    case TokenTypeId.ExpandableModifier:
      addRulesForParent(
        TokenTypeId.ExpandableModifier,
        expandableModifierRules,
      );
      break;
    case TokenTypeId.ExplicitArrayDimension:
      addRulesForParent(
        TokenTypeId.ExplicitArrayDimension,
        explicitArrayDimensionRules,
      );
      break;
    case TokenTypeId.ExpressionStatement:
      addRulesForParent(
        TokenTypeId.ExpressionStatement,
        expressionStatementRules,
      );
      break;
    case TokenTypeId.ExtendedClassIdRange:
      addRulesForParent(
        TokenTypeId.ExtendedClassIdRange,
        extendedClassIdRangeRules,
      );
      break;
    case TokenTypeId.ExtendsModifier:
      addRulesForParent(TokenTypeId.ExtendsModifier, extendsModifierRules);
      break;
    case TokenTypeId.ForStatement:
      addRulesForParent(TokenTypeId.ForStatement, forStatementRules);
      break;
    case TokenTypeId.IfStatement:
      addRulesForParent(TokenTypeId.IfStatement, ifStatementRules);
      break;
    case TokenTypeId.ImplicitArrayDimension:
      addRulesForParent(
        TokenTypeId.ImplicitArrayDimension,
        implicitArrayDimensionRules,
      );
      break;
    case TokenTypeId.LengthAttribute:
      addRulesForParent(TokenTypeId.LengthAttribute, lengthAttributeRules);
      break;
    case TokenTypeId.LengthofExpression:
      addRulesForParent(
        TokenTypeId.LengthofExpression,
        lengthofExpressionRules,
      );
      break;
    case TokenTypeId.MapDeclaration:
      addRulesForParent(TokenTypeId.MapDeclaration, mapDeclarationRules);
      break;
    case TokenTypeId.MapDefinition:
      addRulesForParent(TokenTypeId.MapDefinition, mapDefinitionRules);
      break;
    case TokenTypeId.MapEntry:
      addRulesForParent(TokenTypeId.MapEntry, mapEntryRules);
      break;
    case TokenTypeId.Parameter:
      addRulesForParent(TokenTypeId.Parameter, parameterRules);
      break;
    case TokenTypeId.ParameterList:
      addRulesForParent(TokenTypeId.ParameterList, parameterListRules);
      break;
    case TokenTypeId.ParameterValueList:
      addRulesForParent(
        TokenTypeId.ParameterValueList,
        parameterValueListRules,
      );
      break;
    case TokenTypeId.PartialArrayDimension:
      addRulesForParent(
        TokenTypeId.PartialArrayDimension,
        partialArrayDimensionRules,
      );
      break;
    case TokenTypeId.Specification:
      addRulesForParent(TokenTypeId.Specification, specificationRules);
      break;
    case TokenTypeId.StringDefinition:
      addRulesForParent(TokenTypeId.StringDefinition, stringDefinitionRules);
      break;
    case TokenTypeId.SwitchStatement:
      addRulesForParent(TokenTypeId.SwitchStatement, switchStatementRules);
      break;
    case TokenTypeId.UnaryExpression:
      addRulesForParent(TokenTypeId.UnaryExpression, unaryExpressionRules);
      break;
    case TokenTypeId.UtfStringLiteral:
      addRulesForParent(TokenTypeId.UtfStringLiteral, utfStringLiteralRules);
      break;
    case TokenTypeId.WhileStatement:
      addRulesForParent(TokenTypeId.WhileStatement, whileStatementRules);
      break;
    // Tokens that do not require completion rules
    case TokenTypeId._break:
    case TokenTypeId._case:
    case TokenTypeId._class:
    case TokenTypeId._const:
    case TokenTypeId._default:
    case TokenTypeId._do:
    case TokenTypeId._else:
    case TokenTypeId._extends:
    case TokenTypeId._for:
    case TokenTypeId._if:
    case TokenTypeId._switch:
    case TokenTypeId._while:
    case TokenTypeId.abstract:
    case TokenTypeId.Addition:
    case TokenTypeId.AlignmentBitCount8:
    case TokenTypeId.AlignmentBitCount16:
    case TokenTypeId.AlignmentBitCount32:
    case TokenTypeId.AlignmentBitCount64:
    case TokenTypeId.AlignmentBitCount128:
    case TokenTypeId.aligned:
    case TokenTypeId.Assignment:
    case TokenTypeId.base64string:
    case TokenTypeId.Base64StringLiteral:
    case TokenTypeId.Base64StringLiteralCharacters:
    case TokenTypeId.BinaryLiteral:
    case TokenTypeId.bit:
    case TokenTypeId.BitwiseAnd:
    case TokenTypeId.BitwiseOr:
    case TokenTypeId.BitwiseShiftLeft:
    case TokenTypeId.BitwiseShiftRight:
    case TokenTypeId.CloseBrace:
    case TokenTypeId.CloseBracket:
    case TokenTypeId.CloseParenthesis:
    case TokenTypeId.Colon:
    case TokenTypeId.Comma:
    case TokenTypeId.Comment:
    case TokenTypeId.computed:
    case TokenTypeId.DecimalLiteral:
    case TokenTypeId.Division:
    case TokenTypeId.DoubleQuote:
    case TokenTypeId.expandable:
    case TokenTypeId.float:
    case TokenTypeId.FloatingPointLiteral:
    case TokenTypeId.HexadecimalLiteral:
    case TokenTypeId.Identifier:
    case TokenTypeId.int:
    case TokenTypeId.IntegerLiteral:
    case TokenTypeId.legacy:
    case TokenTypeId.lengthof:
    case TokenTypeId.LogicalAnd:
    case TokenTypeId.LogicalOr:
    case TokenTypeId.LookAhead:
    case TokenTypeId.map:
    case TokenTypeId.Modulus:
    case TokenTypeId.MultipleCharacterLiteral:
    case TokenTypeId.MultipleCharacterLiteralCharacters:
    case TokenTypeId.Multiplication:
    case TokenTypeId.OpenBrace:
    case TokenTypeId.OpenBracket:
    case TokenTypeId.OpenParenthesis:
    case TokenTypeId.Period:
    case TokenTypeId.PostfixDecrement:
    case TokenTypeId.PostfixIncrement:
    case TokenTypeId.RangeOperator:
    case TokenTypeId.reserved:
    case TokenTypeId.RelationalEqual:
    case TokenTypeId.RelationalGreaterThan:
    case TokenTypeId.RelationalGreaterThanOrEqual:
    case TokenTypeId.RelationalLessThan:
    case TokenTypeId.RelationalLessThanOrEqual:
    case TokenTypeId.RelationalNotEqual:
    case TokenTypeId.Semicolon:
    case TokenTypeId.SingleQuote:
    case TokenTypeId.Subtraction:
    case TokenTypeId.UnaryNegation:
    case TokenTypeId.UnaryPlus:
    case TokenTypeId.unsigned:
    case TokenTypeId.utf16string:
    case TokenTypeId.utf8list:
    case TokenTypeId.utf8string:
    case TokenTypeId.utfstring:
    case TokenTypeId.UtfPrefix:
    case TokenTypeId.UtfStringLiteralCharacters:
    case TokenTypeId.Whitespace:
      break;
    default: {
      const exhaustiveCheck: never = tokenTypeId;
      throw new Error(
        "Unreachable code reached, tokenTypeId == " + exhaustiveCheck,
      );
    }
  }
});
