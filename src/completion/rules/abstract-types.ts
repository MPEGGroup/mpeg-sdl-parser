// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../../lezer/parser.terms.ts";

export const expressionTypes = [
  TokenTypeId.UnaryExpression,
  TokenTypeId.BinaryExpression,
];

export const statementTypes = [
  TokenTypeId.CompoundStatement,
  TokenTypeId.IfStatement,
  TokenTypeId.SwitchStatement,
  TokenTypeId.ForStatement,
  TokenTypeId.DoStatement,
  TokenTypeId.WhileStatement,
  TokenTypeId.ExpressionStatement,
  TokenTypeId.ElementaryTypeDefinition,
  TokenTypeId.MapDefinition,
  TokenTypeId.ClassDefinition,
  TokenTypeId.StringDefinition,
  TokenTypeId.ArrayDefinition,
  TokenTypeId.ComputedElementaryTypeDefinition,
  TokenTypeId.ComputedArrayDefinition,
];

export const numberLiteralTypes = [
  TokenTypeId.BinaryLiteral,
  TokenTypeId.HexadecimalLiteral,
  TokenTypeId.MultipleCharacterLiteral,
  TokenTypeId.IntegerLiteral,
  TokenTypeId.DecimalLiteral,
  TokenTypeId.FloatingPointLiteral,
];

export const unaryOperatorTypes = [
  TokenTypeId.UnaryPlus,
  TokenTypeId.UnaryNegation,
];

export const postfixOperatorTypes = [
  TokenTypeId.PostfixIncrement,
  TokenTypeId.PostfixDecrement,
];

export const binaryOperatorTypes = [
  TokenTypeId.Multiplication,
  TokenTypeId.Division,
  TokenTypeId.Modulus,
  TokenTypeId.Addition,
  TokenTypeId.Subtraction,
  TokenTypeId.BitwiseShiftLeft,
  TokenTypeId.BitwiseShiftRight,
  TokenTypeId.RelationalLessThan,
  TokenTypeId.RelationalLessThanOrEqual,
  TokenTypeId.RelationalGreaterThan,
  TokenTypeId.RelationalGreaterThanOrEqual,
  TokenTypeId.RelationalEqual,
  TokenTypeId.RelationalNotEqual,
  TokenTypeId.BitwiseAnd,
  TokenTypeId.BitwiseOr,
  TokenTypeId.LogicalAnd,
  TokenTypeId.LogicalOr,
];
