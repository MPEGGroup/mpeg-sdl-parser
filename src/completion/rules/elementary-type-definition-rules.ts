import { binaryOperatorTypes, expressionTypes } from "./abstract-types.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../../lezer/parser.terms.ts";

export const elementaryTypeDefinitionRules = [
  {
    previous: -1,
    expected: [
      TokenTypeId.reserved,
      TokenTypeId.legacy,
      TokenTypeId._const,
      TokenTypeId.AlignedModifier,
      TokenTypeId.ElementaryType,
    ],
  },
  {
    previous: TokenTypeId.reserved,
    expected: [
      TokenTypeId._const,
      TokenTypeId.AlignedModifier,
      TokenTypeId.ElementaryType,
    ],
  },
  {
    previous: TokenTypeId._const,
    expected: [TokenTypeId.AlignedModifier, TokenTypeId.ElementaryType],
  },
  {
    previous: TokenTypeId.AlignedModifier,
    expected: TokenTypeId.ElementaryType,
  },
  {
    previous: TokenTypeId.ElementaryType,
    expected: TokenTypeId.LengthAttribute,
  },
  {
    previous: TokenTypeId.LengthAttribute,
    expected: [TokenTypeId.LookAhead, TokenTypeId.Identifier],
  },
  {
    previous: TokenTypeId.LookAhead,
    expected: TokenTypeId.Identifier,
  },
  {
    previous: TokenTypeId.Identifier,
    expected: [TokenTypeId.Assignment, TokenTypeId.Semicolon],
  },
  {
    previous: TokenTypeId.Assignment,
    expected: expressionTypes,
  },
  ...expressionTypes.map((expressionType) => ({
    previous: [TokenTypeId.Assignment, expressionType],
    expected: [
      TokenTypeId.RangeOperator,
      TokenTypeId.Semicolon,
      ...binaryOperatorTypes,
    ],
  })),
  { previous: TokenTypeId.RangeOperator, expected: expressionTypes },
];
