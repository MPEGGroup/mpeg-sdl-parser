import type { NodeType, TreeCursor } from "@lezer/common";
import { completionRulesByParentMap } from "./completionRules.ts";
import getLogger from "../util/logger.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../lezer/parser.terms.ts";

const logger = getLogger("getExpectedTokenTypeIds");

/**
 * Given a TreeCursor positioned at an error node, returns the expected token types at that position.
 *
 * @param errorCursor The TreeCursor positioned at an error node.
 *
 * @returns An array of expected NodeType IDs, or undefined if none found.
 */
export function getExpectedTokenTypeIds(
  errorCursor: TreeCursor,
): number[] | undefined {
  // firstly clone the cursor to avoid breaking the traversal of the original cursor
  const parentCursorClone = errorCursor.node.cursor();
  const siblingCursorClone = errorCursor.node.cursor();

  // look for parent token type, ignoring whitespace
  const parentTokenTypes: NodeType[] = [];

  while (parentCursorClone.parent()) {
    if (parentCursorClone.type.id !== TokenTypeId.Whitespace) {
      parentTokenTypes.unshift(parentCursorClone.type);
      break;
    }
  }

  if (parentTokenTypes.length === 0) {
    logger.debug("No parent token type found");
    return undefined;
  }

  // look for previous sibling token types, ignoring whitespace
  const previousSiblingTokenTypes: NodeType[] = [];

  while (siblingCursorClone.prevSibling()) {
    if (siblingCursorClone.type.id !== TokenTypeId.Whitespace) {
      previousSiblingTokenTypes.unshift(siblingCursorClone.type);
    }
  }

  logger.debug(
    "parentTokenTypes: " + parentTokenTypes.map((type) => type.name).join(", "),
  );

  if (previousSiblingTokenTypes.length > 0) {
    logger.debug(
      "previousSiblingTokenTypes: " +
        previousSiblingTokenTypes.map((type) => type.name).join(", "),
    );
  } else {
    logger.debug("No previous sibling token type found");
  }

  const expectedTokensByPreviousSiblingMap = completionRulesByParentMap.get(
    parentTokenTypes[parentTokenTypes.length - 1].id,
  );

  if (!expectedTokensByPreviousSiblingMap) {
    logger.debug(
      "No expected tokens map found for parentTokenType: " +
        parentTokenTypes[parentTokenTypes.length - 1].name,
    );

    return undefined;
  }

  const expectedTokenTypes = expectedTokensByPreviousSiblingMap.get(
    previousSiblingTokenTypes.length > 0
      ? [-1, ...previousSiblingTokenTypes.map((type) => type.id)]
      : [-1],
  );

  if (!expectedTokenTypes) {
    logger.debug(
      "No expected tokens found for parentTokenTypes: " +
        parentTokenTypes.map((type) => type.name).join(", ") +
        (previousSiblingTokenTypes.length > 0
          ? " and previousSiblingTokenTypes: " +
            previousSiblingTokenTypes.map((type) => type.name).join(", ")
          : ""),
    );
    return undefined;
  }

  return expectedTokenTypes;
}
