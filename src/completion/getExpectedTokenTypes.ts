import type { NodeType, TreeCursor } from "@lezer/common";
import { createLenientSdlParser } from "../lezer/createSdlParser.ts";
import { completionRulesByParentMap } from "./completionRules.ts";
import getLogger from "../util/logger.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../lezer/parser.terms.ts";

const logger = getLogger("getExpectedTokenTypes");

const lenientSdlParser = createLenientSdlParser();

export function getExpectedTokenTypes(
  errorCursor: TreeCursor,
): NodeType[] | undefined {
  // firstly clone the cursor to avoid breaking the traversal of the original cursor
  const parentCursorClone = errorCursor.node.cursor();
  const siblingCursorClone = errorCursor.node.cursor();

  // look for parent token type, ignoring whitespace
  const parentTokenTypes: NodeType[] = [];

  while (parentCursorClone.parent()) {
    if (parentCursorClone.type.id !== TokenTypeId.Whitespace) {
      parentTokenTypes.unshift(parentCursorClone.type);
      break;
    }
  }

  if (parentTokenTypes.length === 0) {
    logger.debug("No parent token type found");
    return undefined;
  }

  // look for previous sibling token types, ignoring whitespace
  const previousSiblingTokenTypes: NodeType[] = [];

  while (siblingCursorClone.prevSibling()) {
    if (siblingCursorClone.type.id !== TokenTypeId.Whitespace) {
      previousSiblingTokenTypes.unshift(siblingCursorClone.type);
    }
  }

  logger.debug(
    "parentTokenTypes: " + parentTokenTypes.map((type) => type.name).join(", "),
  );

  if (previousSiblingTokenTypes.length > 0) {
    logger.debug(
      "previousSiblingTokenTypes: " +
        previousSiblingTokenTypes.map((type) => type.name).join(", "),
    );
  } else {
    logger.debug("No previous sibling token type found");
  }

  const expectedTokensByPreviousSiblingMap = completionRulesByParentMap.get(
    parentTokenTypes[parentTokenTypes.length - 1].id,
  );

  if (!expectedTokensByPreviousSiblingMap) {
    logger.debug(
      "No expected tokens map found for parentTokenType: " +
        parentTokenTypes[parentTokenTypes.length - 1].name,
    );

    // try again with the parent
    return getExpectedTokenTypes(parentCursorClone);
  }

  const expectedTokenTypes = expectedTokensByPreviousSiblingMap.get(
    previousSiblingTokenTypes.length > 0
      ? previousSiblingTokenTypes.map((type) => type.id)
      : [-1],
  );

  if (!expectedTokenTypes) {
    logger.debug(
      "No expected tokens found for parentTokenTypes: " +
        parentTokenTypes.map((type) => type.name).join(", ") +
        (previousSiblingTokenTypes.length > 0
          ? " and previousSiblingTokenTypes: " +
            previousSiblingTokenTypes.map((type) => type.name).join(", ")
          : ""),
    );
    return undefined;
  }

  return expectedTokenTypes.map((tokenTypeId) =>
    lenientSdlParser.nodeSet.types[tokenTypeId]
  );
}
