import type { AbstractNode } from "../node/AbstractNode.ts";
import type { BuildContext } from "../build/BuildContext.ts";
import { createParseErrorFromTextAndCursor } from "../../lezer/createParseErrorFromTextAndCursor.ts";
import { primitiveNodeProp } from "../../lezer/props/primitiveNodePropSource.ts";
import { buildSpecification } from "../build/buildSpecification.ts";
import { MissingError } from "../node/MissingError.ts";
import { UnexpectedError } from "../node/UnexpectedError.ts";
import { buildToken } from "../build/buildToken.ts";
import { buildIdentifier } from "../build/buildIdentifier.ts";
import { buildHexadecimalLiteral } from "../build/buildHexadecimalLiteral.ts";
import { buildIntegerLiteral } from "../build/buildIntegerLiteral.ts";
import { buildDecimalLiteral } from "../build/buildDecimalLiteral.ts";
import { buildBinaryLiteral } from "../build/buildBinaryLiteral.ts";
import { buildFloatingPointLiteral } from "../build/buildFloatingPointLiteral.ts";
import { buildClassDeclaration } from "../build/buildClassDeclaration.ts";
import { buildExpressionStatement } from "../build/buildExpressionStatement.ts";
import { buildUnaryExpression } from "../build/buildUnaryExpression.ts";
import { consumeTrivia } from "./consumeTrivia.ts";
import { InternalParseError } from "../../ParseError.ts";
import getLogger from "../../util/logger.ts";
import { NodeKind } from "../node/enum/node_kind.ts";
import { buildElementaryTypeDefinition } from "../build/buildElementaryTypeDefinition.ts";
import { buildComputedElementaryTypeDefinition } from "../build/buildComputedElementaryTypeDefinition.ts";
import { buildElementaryType } from "../build/buildElementaryType.ts";
import { buildLengthAttribute } from "../build/buildLengthAttribute.ts";
import { buildAlignedModifier } from "../build/buildAlignedModifier.ts";
import { buildClassMemberAccess } from "../build/buildClassMemberAccess.ts";
import { buildComputedArrayDefinition } from "../build/buildComputedArrayDefinition.ts";
import { buildExplicitArrayDimension } from "../build/buildExplicitArrayDimension.ts";
import { buildImplicitArrayDimension } from "../build/buildImplicitArrayDimension.ts";
import { buildPartialArrayDimension } from "../build/buildPartialArrayDimension.ts";
import { buildArrayElementAccess } from "../build/buildArrayElementAccess.ts";
import { buildArrayDefinition } from "../build/buildArrayDefinition.ts";
import { buildAggregateOutputValue } from "../build/buildAggregateOutputValue.ts";
import { buildAssignmentExpression } from "../build/buildAssignmentExpression.ts";
import { buildBase64StringLiteral } from "../build/buildBase64StringLiteral.ts";
import { buildBinaryExpression } from "../build/buildBinaryExpression.ts";
import { buildBitModifier } from "../build/buildBitModifier.ts";
import { buildStringDefinition } from "../build/buildStringDefinition.ts";
import { buildSwitchStatement } from "../build/buildSwitchStatement.ts";
import { buildUtfStringLiteral } from "../build/buildUtfStringLiteral.ts";
import { buildWhileStatement } from "../build/buildWhileStatement.ts";
import { buildParameterValueList } from "../build/buildParameterValueList.ts";
import { buildParameterList } from "../build/buildParameterList.ts";
import { buildParameter } from "../build/buildParameter.ts";
import { buildMultipleCharacterLiteral } from "../build/buildMultipleCharacterLiteral.ts";
import { buildMapEntry } from "../build/buildMapEntry.ts";
import { buildMapDeclaration } from "../build/buildMapDeclaration.ts";
import { buildLengthofExpression } from "../build/buildLengthofExpression.ts";
import { buildIfStatement } from "../build/buildIfStatement.ts";
import { buildForStatement } from "../build/buildForStatement.ts";
import { buildCaseClause } from "../build/buildCaseClause.ts";
import { buildClassDefinition } from "../build/buildClassDefinition.ts";
import { buildClassId } from "../build/buildClassId.ts";
import { buildClassIdRange } from "../build/buildClassIdRange.ts";
import { buildCompoundStatement } from "../build/buildCompoundStatement.ts";
import { buildDefaultClause } from "../build/buildDefaultClause.ts";
import { buildDoStatement } from "../build/buildDoStatement.ts";
import { buildExtendsModifier } from "../build/buildExtendsModifier.ts";
import { buildExtendedClassIdRange } from "../build/buildExtendedClassIdRange.ts";
import { buildExpandableModifier } from "../build/buildExpandableModifier.ts";
import { buildElementaryTypeOutputValue } from "../build/buildElementaryTypeOutputValue.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../../lezer/parser.terms.ts";
import { getLocationFromTextPosition } from "../../util/locationUtils.ts";
import { tokenKindByTokenTypeId } from "../node/enum/token_kind.ts";
import { Specification } from "../node/Specification.ts";

const logger = getLogger("consumeNode");

/*
 * Iterate through the syntax tree and consume parse tree tokens to create an AST node.
 * Return undefined if at EOF.
 */
export function consumeNode(
  buildContext: BuildContext,
): AbstractNode | undefined {
  const { cursor, text, lenient } = buildContext;

  // If current node is Specification and no siblings, we are at EOF
  if (buildContext.isEndOfSiblings) {
    return undefined;
  }

  // get any trivia which will be leading trivia for the next node we process
  const leadingTrivia = consumeTrivia(buildContext);

  let indent = "  ".repeat(buildContext.depth);
  if (leadingTrivia.length > 0) {
    logger.debug(
      indent + "consumed leading trivia: " +
        leadingTrivia.map((trivia) => trivia.text.replaceAll("\n", "\\n")).join(
          ", ",
        ),
    );
  }

  const isError = cursor.type.isError;

  if (isError && !lenient) {
    throw createParseErrorFromTextAndCursor(text, cursor);
  }

  let isUnexpectedError = false;
  let isMissingError = false;

  // Check if current sytax node is a terminal token by attempting to move to first child
  const childExists = cursor.firstChild();

  let isTerminal: boolean;
  // If the cursor was an error and it has a child, it is an unexpected token error
  // In this case the child is the unexpected token, so keep pointing at the child token
  // and set isTerminal to true
  if (isError && childExists) {
    isTerminal = true;
    isUnexpectedError = true;
  } // If it is an error and no child exists, it is a missing token error
  // Set isTerminal to true
  else if (isError && !childExists) {
    isMissingError = true;
    isTerminal = true;
  } // Otherwise we have a child but we should not use it yet
  // so move back to parent and set isTerminal to false
  else if (childExists) {
    cursor.parent();
    isTerminal = false;
  } // Otherwise no child exists so it is terminal
  else {
    isTerminal = true;
  }

  let consumedChildNode = false;
  let node;

  // Primitive is a terminal custom text rather than a syntax token, this will be treated slightly differently
  const isPrimitive = cursor.type.prop(primitiveNodeProp);

  // It might be a terminal node because there are missing children, in which case it is not a terminal token
  // but a terminal AST node, this will be treated slightly differently i.e. treat it as a node
  const isTokenType = tokenKindByTokenTypeId.get(cursor.type.id) !== undefined;

  if (isMissingError) {
    logger.debug(indent + "consumed missing error node");
    const location = getLocationFromTextPosition(text, cursor.from);
    node = new MissingError(location);
  } else if (isTerminal && (isPrimitive || isTokenType)) {
    // Create a Token
    const token = buildToken(buildContext);

    if (isUnexpectedError) {
      // Create non-token AST node (which contains a TokenNode)
      node = new UnexpectedError(token);
      logger.debug(
        indent + "consumed unexpected error node: " +
          token.text.replaceAll("\n", "\\n"),
      );
    } // Primitives are terminal tokens but we want to create non-token AST nodes for them (which contain a TokenNode)
    else if (isPrimitive) {
      switch (cursor.type.id) {
        case TokenTypeId.Identifier:
          node = buildIdentifier(token);
          break;
        case TokenTypeId.HexadecimalLiteral:
          node = buildHexadecimalLiteral(token);
          break;
        case TokenTypeId.IntegerLiteral:
          node = buildIntegerLiteral(token);
          break;
        case TokenTypeId.BinaryLiteral:
          node = buildBinaryLiteral(token);
          break;
        case TokenTypeId.DecimalLiteral:
          node = buildDecimalLiteral(token);
          break;
        case TokenTypeId.FloatingPointLiteral:
          node = buildFloatingPointLiteral(token);
          break;
        default:
          throw new Error(
            `Unsupported primitive type: ${cursor.type.name}`,
          );
      }
      logger.debug(
        indent + "consumed primitive node: " + NodeKind[node.nodeKind] + " " +
          token.text.replaceAll("\n", "\\n"),
      );
    } // Otherwise use the Token as is
    else {
      node = token;

      logger.debug(
        indent +
          "consumed token node: " + token.text.replaceAll("\n", "\\n"),
      );
    }
  } else {
    // Otherwise create an AST node from the syntax node
    const parentTypeId = cursor.type.id;
    const parentTypeName = cursor.type.name;

    logger.debug(indent + "consuming node: " + parentTypeName + "...");

    const hasChild = cursor.firstChild();

    if (!hasChild) {
      // Allow specification to have no children
      if (parentTypeId == TokenTypeId.Specification) {
        return new Specification([]);
      } else {
        throw new InternalParseError(
          `Expected node to have at least one child: ${parentTypeName}`,
        );
      }
    }
    buildContext.depth += 1;
    switch (parentTypeId) {
      case TokenTypeId.AggregateOutputValue:
        node = buildAggregateOutputValue(buildContext);
        break;
      case TokenTypeId.AlignedModifier:
        node = buildAlignedModifier(buildContext);
        break;
      case TokenTypeId.ArrayDefinition:
        node = buildArrayDefinition(buildContext);
        break;
      case TokenTypeId.ArrayElementAccess:
        node = buildArrayElementAccess(buildContext);
        break;
      case TokenTypeId.AssignmentExpression:
        node = buildAssignmentExpression(buildContext);
        break;
      case TokenTypeId.Base64StringLiteral:
        node = buildBase64StringLiteral(buildContext);
        break;
      case TokenTypeId.BinaryExpression:
        node = buildBinaryExpression(buildContext);
        break;
      case TokenTypeId.BitModifier:
        node = buildBitModifier(buildContext);
        break;
      case TokenTypeId.CaseClause:
        node = buildCaseClause(buildContext);
        break;
      case TokenTypeId.ClassDeclaration:
        node = buildClassDeclaration(buildContext);
        break;
      case TokenTypeId.ClassDefinition:
        node = buildClassDefinition(buildContext);
        break;
      case TokenTypeId.ClassId:
        node = buildClassId(buildContext);
        break;
      case TokenTypeId.ClassIdRange:
        node = buildClassIdRange(buildContext);
        break;
      case TokenTypeId.ClassMemberAccess:
        node = buildClassMemberAccess(buildContext);
        break;
      case TokenTypeId.CompoundStatement:
        node = buildCompoundStatement(buildContext);
        break;
      case TokenTypeId.ComputedArrayDefinition:
        node = buildComputedArrayDefinition(buildContext);
        break;
      case TokenTypeId.ComputedElementaryTypeDefinition:
        node = buildComputedElementaryTypeDefinition(buildContext);
        break;
      case TokenTypeId.DefaultClause:
        node = buildDefaultClause(buildContext);
        break;
      case TokenTypeId.DoStatement:
        node = buildDoStatement(buildContext);
        break;
      case TokenTypeId.ElementaryType:
        node = buildElementaryType(buildContext);
        break;
      case TokenTypeId.ElementaryTypeDefinition:
        node = buildElementaryTypeDefinition(buildContext);
        break;
      case TokenTypeId.ElementaryTypeOutputValue:
        node = buildElementaryTypeOutputValue(buildContext);
        break;
      case TokenTypeId.ExpandableModifier:
        node = buildExpandableModifier(buildContext);
        break;
      case TokenTypeId.ExplicitArrayDimension:
        node = buildExplicitArrayDimension(buildContext);
        break;
      case TokenTypeId.ExpressionStatement:
        node = buildExpressionStatement(buildContext);
        break;
      case TokenTypeId.ExtendedClassIdRange:
        node = buildExtendedClassIdRange(buildContext);
        break;
      case TokenTypeId.ExtendsModifier:
        node = buildExtendsModifier(buildContext);
        break;
      case TokenTypeId.ForStatement:
        node = buildForStatement(buildContext);
        break;
      case TokenTypeId.IfStatement:
        node = buildIfStatement(buildContext);
        break;
      case TokenTypeId.ImplicitArrayDimension:
        node = buildImplicitArrayDimension(buildContext);
        break;
      case TokenTypeId.LengthAttribute:
        node = buildLengthAttribute(buildContext);
        break;
      case TokenTypeId.LengthofExpression:
        node = buildLengthofExpression(buildContext);
        break;
      case TokenTypeId.MapDeclaration:
        node = buildMapDeclaration(buildContext);
        break;
      case TokenTypeId.MapEntry:
        node = buildMapEntry(buildContext);
        break;
      case TokenTypeId.MultipleCharacterLiteral:
        node = buildMultipleCharacterLiteral(buildContext);
        break;
      case TokenTypeId.Parameter:
        node = buildParameter(buildContext);
        break;
      case TokenTypeId.ParameterList:
        node = buildParameterList(buildContext);
        break;
      case TokenTypeId.ParameterValueList:
        node = buildParameterValueList(buildContext);
        break;
      case TokenTypeId.PartialArrayDimension:
        node = buildPartialArrayDimension(buildContext);
        break;
      case TokenTypeId.Specification:
        node = buildSpecification(buildContext);
        break;
      case TokenTypeId.StringDefinition:
        node = buildStringDefinition(buildContext);
        break;
      case TokenTypeId.SwitchStatement:
        node = buildSwitchStatement(buildContext);
        break;
      case TokenTypeId.UtfStringLiteral:
        node = buildUtfStringLiteral(buildContext);
        break;
      case TokenTypeId.UnaryExpression:
        node = buildUnaryExpression(buildContext);
        break;
      case TokenTypeId.WhileStatement:
        node = buildWhileStatement(buildContext);
        break;

      // These are primitive node types that should have been handled above
      case TokenTypeId.Identifier:
      case TokenTypeId.HexadecimalLiteral:
      case TokenTypeId.IntegerLiteral:
      case TokenTypeId.BinaryLiteral:
      case TokenTypeId.DecimalLiteral:
      case TokenTypeId.FloatingPointLiteral:
      default:
        throw new Error(
          `Unsupported or unexpected node: ${parentTypeName}`,
        );
    }
    buildContext.depth -= 1;

    indent = "  ".repeat(buildContext.depth);
    logger.debug(indent + "...consumed node: " + parentTypeName);
    consumedChildNode = true;
  }

  if (leadingTrivia.length > 0) {
    node.leadingTrivia = leadingTrivia;
  }

  if (!consumedChildNode) {
    if (cursor.nextSibling()) {
      buildContext.isEndOfSiblings = false;
    } else {
      buildContext.isEndOfSiblings = true;
    }
  }

  // Get any trailing trivia for the node
  if (!buildContext.isEndOfSiblings) {
    const trailingTrivia = consumeTrivia(buildContext);

    if (trailingTrivia.length > 0) {
      indent = "  ".repeat(buildContext.depth);
      logger.debug(
        indent +
          "consumed trailing trivia: " +
          trailingTrivia.map((trivia) => trivia.text.replaceAll("\n", "\\n"))
            .join(
              ", ",
            ),
      );
      node.trailingTrivia = trailingTrivia;
    }
  }

  // Check if we are at end of siblings and need to move back to parent
  if (buildContext.isEndOfSiblings) {
    buildContext.isEndOfSiblings = false;
    if (!cursor.nextSibling()) {
      indent = "  ".repeat(buildContext.depth);
      logger.debug(indent + "no next sibling, moving back to parent");
      if (cursor.parent()) {
        indent = "  ".repeat(buildContext.depth);
        logger.debug(indent + "now at parent: " + cursor.type.name);

        buildContext.isEndOfSiblings = true;
        let hasSibling = cursor.nextSibling();
        // move to next non-whitespace sibling
        while (hasSibling) {
          if (cursor.type.name !== "Whitespace") {
            buildContext.isEndOfSiblings = false;
            break;
          }
          // skip whitespace siblings
          hasSibling = cursor.nextSibling();
        }
        if (buildContext.isEndOfSiblings) {
          logger.debug(indent + "no next sibling at parent, end of siblings");
        } else {
          logger.debug(indent + "now at sibling: " + cursor.type.name);
        }
      } else {
        buildContext.isEndOfSiblings = true;
      }
    }
  }

  return node;
}
