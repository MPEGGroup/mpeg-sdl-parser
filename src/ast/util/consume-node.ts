import type { AbstractNode } from "../node/abstract-node.ts";
import type { BuildContext } from "../build/build-context.ts";
import { createParseErrorFromTextAndCursor } from "../../lezer/create-parse-error-from-text-and-cursor.ts";
import { primitiveNodeProp } from "../../lezer/props/primitive-node-prop-source.ts";
import { buildSpecification } from "../build/build-specification.ts";
import { MissingError } from "../node/missing-error.ts";
import { UnexpectedError } from "../node/unexpected-error.ts";
import { buildToken } from "../build/build-token.ts";
import { buildIdentifier } from "../build/build-identifier.ts";
import { buildHexadecimalLiteral } from "../build/build-hexadecimal-literal.ts";
import { buildIntegerLiteral } from "../build/build-integer-literal.ts";
import { buildDecimalLiteral } from "../build/build-decimal-literal.ts";
import { buildBinaryLiteral } from "../build/build-binary-literal.ts";
import { buildFloatingPointLiteral } from "../build/build-floating-point-literal.ts";
import { buildClassDeclaration } from "../build/build-class-declaration.ts";
import { buildExpressionStatement } from "../build/build-expression-statement.ts";
import { buildUnaryExpression } from "../build/build-unary-expression.ts";
import { consumeTrivia } from "./consume-trivia.ts";
import { InternalParseError } from "../../parse-error.ts";
import getLogger from "../../util/logger.ts";
import { NodeKind } from "../node/enum/node-kind.ts";
import { buildElementaryTypeDefinition } from "../build/build-elementary-type-definition.ts";
import { buildComputedElementaryTypeDefinition } from "../build/build-computed-elementary-type-definition.ts";
import { buildElementaryType } from "../build/build-elementary-type.ts";
import { buildLengthAttribute } from "../build/build-length-attribute.ts";
import { buildAlignedModifier } from "../build/build-aligned-modifier.ts";
import { buildClassMemberAccess } from "../build/build-class-member-access.ts";
import { buildComputedArrayDefinition } from "../build/build-computed-array-definition.ts";
import { buildExplicitArrayDimension } from "../build/build-explicit-array-dimension.ts";
import { buildImplicitArrayDimension } from "../build/build-implicit-array-dimension.ts";
import { buildPartialArrayDimension } from "../build/build-partial-array-dimension.ts";
import { buildArrayElementAccess } from "../build/build-array-element-access.ts";
import { buildArrayDefinition } from "../build/build-array-definition.ts";
import { buildAggregateOutputValue } from "../build/build-aggregate-output-value.ts";
import { buildAssignmentExpression } from "../build/build-assignment-expression.ts";
import { buildBase64StringLiteral } from "../build/build-base64-string-literal.ts";
import { buildBinaryExpression } from "../build/build-binary-expression.ts";
import { buildBitModifier } from "../build/build-bit-modifier.ts";
import { buildStringDefinition } from "../build/build-string-definition.ts";
import { buildSwitchStatement } from "../build/build-switch-statement.ts";
import { buildUtfStringLiteral } from "../build/build-utf-string-literal.ts";
import { buildWhileStatement } from "../build/build-while-statement.ts";
import { buildParameterValueList } from "../build/build-parameter-value-list.ts";
import { buildParameterList } from "../build/build-parameter-list.ts";
import { buildParameter } from "../build/build-parameter.ts";
import { buildMultipleCharacterLiteral } from "../build/build-multiple-character-literal.ts";
import { buildMapEntry } from "../build/build-map-entry.ts";
import { buildMapDeclaration } from "../build/build-map-declaration.ts";
import { buildLengthofExpression } from "../build/build-lengthof-expression.ts";
import { buildIfStatement } from "../build/build-if-statement.ts";
import { buildForStatement } from "../build/build-for-statement.ts";
import { buildCaseClause } from "../build/build-case-clause.ts";
import { buildClassDefinition } from "../build/build-class-definition.ts";
import { buildClassId } from "../build/build-class-id.ts";
import { buildClassIdRange } from "../build/build-class-id-range.ts";
import { buildCompoundStatement } from "../build/build-compound-statement.ts";
import { buildDefaultClause } from "../build/build-default-clause.ts";
import { buildDoStatement } from "../build/build-do-statement.ts";
import { buildExtendsModifier } from "../build/build-extends-modifier.ts";
import { buildExtendedClassIdRange } from "../build/build-extended-class-id-range.ts";
import { buildExpandableModifier } from "../build/build-expandable-modifier.ts";
import { buildElementaryTypeOutputValue } from "../build/build-elementary-type-output-value.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../../lezer/parser.terms.ts";
import { getLocationFromTextPosition } from "../../util/location-utils.ts";
import { tokenKindByTokenTypeId } from "../node/enum/token-kind.ts";
import { Specification } from "../node/specification.ts";

const logger = getLogger("consumeNode");

/*
 * Iterate through the syntax tree and consume parse tree tokens to create an AST node.
 * Return undefined if at EOF.
 */
export function consumeNode(
  buildContext: BuildContext,
): AbstractNode | undefined {
  const { cursor, text, lenient } = buildContext;

  // If current node is Specification and no siblings, we are at EOF
  if (buildContext.isEndOfSiblings) {
    return undefined;
  }

  // get any trivia which will be leading trivia for the next node we process
  const leadingTrivia = consumeTrivia(buildContext);

  let indent = "  ".repeat(buildContext.depth);
  if (leadingTrivia.length > 0) {
    logger.debug(
      indent + "consumed leading trivia: " +
        leadingTrivia.map((trivia) => trivia.text.replaceAll("\n", "\\n")).join(
          ", ",
        ),
    );
  }

  const isError = cursor.type.isError;

  if (isError && !lenient) {
    throw createParseErrorFromTextAndCursor(text, cursor);
  }

  let isUnexpectedError = false;
  let isMissingError = false;

  // Check if current sytax node is a terminal token by attempting to move to first child
  const childExists = cursor.firstChild();

  let isTerminal: boolean;
  // If the cursor was an error and it has a child, it is an unexpected token error
  // In this case the child is the unexpected token, so keep pointing at the child token
  // and set isTerminal to true
  if (isError && childExists) {
    isTerminal = true;
    isUnexpectedError = true;
  } // If it is an error and no child exists, it is a missing token error
  // Set isTerminal to true
  else if (isError && !childExists) {
    isMissingError = true;
    isTerminal = true;
  } // Otherwise we have a child but we should not use it yet
  // so move back to parent and set isTerminal to false
  else if (childExists) {
    cursor.parent();
    isTerminal = false;
  } // Otherwise no child exists so it is terminal
  else {
    isTerminal = true;
  }

  let consumedChildNode = false;
  let node;

  // Primitive is a terminal custom text rather than a syntax token, this will be treated slightly differently
  const isPrimitive = cursor.type.prop(primitiveNodeProp);

  // It might be a terminal node because there are missing children, in which case it is not a terminal token
  // but a terminal AST node, this will be treated slightly differently i.e. treat it as a node
  const isTokenType = tokenKindByTokenTypeId.get(cursor.type.id) !== undefined;

  if (isMissingError) {
    logger.debug(indent + "consumed missing error node");
    const location = getLocationFromTextPosition(text, cursor.from);
    node = new MissingError(location);
  } else if (isTerminal && (isPrimitive || isTokenType)) {
    // Create a Token
    const token = buildToken(buildContext);

    if (isUnexpectedError) {
      // Create non-token AST node (which contains a TokenNode)
      node = new UnexpectedError(token);
      logger.debug(
        indent + "consumed unexpected error node: " +
          token.text.replaceAll("\n", "\\n"),
      );
    } // Primitives are terminal tokens but we want to create non-token AST nodes for them (which contain a TokenNode)
    else if (isPrimitive) {
      switch (cursor.type.id) {
        case TokenTypeId.Identifier:
          node = buildIdentifier(token);
          break;
        case TokenTypeId.HexadecimalLiteral:
          node = buildHexadecimalLiteral(token);
          break;
        case TokenTypeId.IntegerLiteral:
          node = buildIntegerLiteral(token);
          break;
        case TokenTypeId.BinaryLiteral:
          node = buildBinaryLiteral(token);
          break;
        case TokenTypeId.DecimalLiteral:
          node = buildDecimalLiteral(token);
          break;
        case TokenTypeId.FloatingPointLiteral:
          node = buildFloatingPointLiteral(token);
          break;
        default:
          throw new Error(
            `Unsupported primitive type: ${cursor.type.name}`,
          );
      }
      logger.debug(
        indent + "consumed primitive node: " + NodeKind[node.nodeKind] + " " +
          token.text.replaceAll("\n", "\\n"),
      );
    } // Otherwise use the Token as is
    else {
      node = token;

      logger.debug(
        indent +
          "consumed token node: " + token.text.replaceAll("\n", "\\n"),
      );
    }
  } else {
    // Otherwise create an AST node from the syntax node
    const parentTypeId = cursor.type.id;
    const parentTypeName = cursor.type.name;

    logger.debug(indent + "consuming node: " + parentTypeName + "...");

    const hasChild = cursor.firstChild();

    if (!hasChild) {
      // Allow specification to have no children
      if (parentTypeId == TokenTypeId.Specification) {
        return new Specification([]);
      } else {
        throw new InternalParseError(
          `Expected node to have at least one child: ${parentTypeName}`,
        );
      }
    }
    buildContext.depth += 1;
    switch (parentTypeId) {
      case TokenTypeId.AggregateOutputValue:
        node = buildAggregateOutputValue(buildContext);
        break;
      case TokenTypeId.AlignedModifier:
        node = buildAlignedModifier(buildContext);
        break;
      case TokenTypeId.ArrayDefinition:
        node = buildArrayDefinition(buildContext);
        break;
      case TokenTypeId.ArrayElementAccess:
        node = buildArrayElementAccess(buildContext);
        break;
      case TokenTypeId.AssignmentExpression:
        node = buildAssignmentExpression(buildContext);
        break;
      case TokenTypeId.Base64StringLiteral:
        node = buildBase64StringLiteral(buildContext);
        break;
      case TokenTypeId.BinaryExpression:
        node = buildBinaryExpression(buildContext);
        break;
      case TokenTypeId.BitModifier:
        node = buildBitModifier(buildContext);
        break;
      case TokenTypeId.CaseClause:
        node = buildCaseClause(buildContext);
        break;
      case TokenTypeId.ClassDeclaration:
        node = buildClassDeclaration(buildContext);
        break;
      case TokenTypeId.ClassDefinition:
        node = buildClassDefinition(buildContext);
        break;
      case TokenTypeId.ClassId:
        node = buildClassId(buildContext);
        break;
      case TokenTypeId.ClassIdRange:
        node = buildClassIdRange(buildContext);
        break;
      case TokenTypeId.ClassMemberAccess:
        node = buildClassMemberAccess(buildContext);
        break;
      case TokenTypeId.CompoundStatement:
        node = buildCompoundStatement(buildContext);
        break;
      case TokenTypeId.ComputedArrayDefinition:
        node = buildComputedArrayDefinition(buildContext);
        break;
      case TokenTypeId.ComputedElementaryTypeDefinition:
        node = buildComputedElementaryTypeDefinition(buildContext);
        break;
      case TokenTypeId.DefaultClause:
        node = buildDefaultClause(buildContext);
        break;
      case TokenTypeId.DoStatement:
        node = buildDoStatement(buildContext);
        break;
      case TokenTypeId.ElementaryType:
        node = buildElementaryType(buildContext);
        break;
      case TokenTypeId.ElementaryTypeDefinition:
        node = buildElementaryTypeDefinition(buildContext);
        break;
      case TokenTypeId.ElementaryTypeOutputValue:
        node = buildElementaryTypeOutputValue(buildContext);
        break;
      case TokenTypeId.ExpandableModifier:
        node = buildExpandableModifier(buildContext);
        break;
      case TokenTypeId.ExplicitArrayDimension:
        node = buildExplicitArrayDimension(buildContext);
        break;
      case TokenTypeId.ExpressionStatement:
        node = buildExpressionStatement(buildContext);
        break;
      case TokenTypeId.ExtendedClassIdRange:
        node = buildExtendedClassIdRange(buildContext);
        break;
      case TokenTypeId.ExtendsModifier:
        node = buildExtendsModifier(buildContext);
        break;
      case TokenTypeId.ForStatement:
        node = buildForStatement(buildContext);
        break;
      case TokenTypeId.IfStatement:
        node = buildIfStatement(buildContext);
        break;
      case TokenTypeId.ImplicitArrayDimension:
        node = buildImplicitArrayDimension(buildContext);
        break;
      case TokenTypeId.LengthAttribute:
        node = buildLengthAttribute(buildContext);
        break;
      case TokenTypeId.LengthofExpression:
        node = buildLengthofExpression(buildContext);
        break;
      case TokenTypeId.MapDeclaration:
        node = buildMapDeclaration(buildContext);
        break;
      case TokenTypeId.MapEntry:
        node = buildMapEntry(buildContext);
        break;
      case TokenTypeId.MultipleCharacterLiteral:
        node = buildMultipleCharacterLiteral(buildContext);
        break;
      case TokenTypeId.Parameter:
        node = buildParameter(buildContext);
        break;
      case TokenTypeId.ParameterList:
        node = buildParameterList(buildContext);
        break;
      case TokenTypeId.ParameterValueList:
        node = buildParameterValueList(buildContext);
        break;
      case TokenTypeId.PartialArrayDimension:
        node = buildPartialArrayDimension(buildContext);
        break;
      case TokenTypeId.Specification:
        node = buildSpecification(buildContext);
        break;
      case TokenTypeId.StringDefinition:
        node = buildStringDefinition(buildContext);
        break;
      case TokenTypeId.SwitchStatement:
        node = buildSwitchStatement(buildContext);
        break;
      case TokenTypeId.UtfStringLiteral:
        node = buildUtfStringLiteral(buildContext);
        break;
      case TokenTypeId.UnaryExpression:
        node = buildUnaryExpression(buildContext);
        break;
      case TokenTypeId.WhileStatement:
        node = buildWhileStatement(buildContext);
        break;

      // These are primitive node types that should have been handled above
      case TokenTypeId.Identifier:
      case TokenTypeId.HexadecimalLiteral:
      case TokenTypeId.IntegerLiteral:
      case TokenTypeId.BinaryLiteral:
      case TokenTypeId.DecimalLiteral:
      case TokenTypeId.FloatingPointLiteral:
      default:
        throw new Error(
          `Unsupported or unexpected node: ${parentTypeName}`,
        );
    }
    buildContext.depth -= 1;

    indent = "  ".repeat(buildContext.depth);
    logger.debug(indent + "...consumed node: " + parentTypeName);
    consumedChildNode = true;
  }

  if (leadingTrivia.length > 0) {
    node.leadingTrivia = leadingTrivia;
  }

  if (!consumedChildNode) {
    if (cursor.nextSibling()) {
      buildContext.isEndOfSiblings = false;
    } else {
      buildContext.isEndOfSiblings = true;
    }
  }

  // Get any trailing trivia for the node
  if (!buildContext.isEndOfSiblings) {
    const trailingTrivia = consumeTrivia(buildContext);

    if (trailingTrivia.length > 0) {
      indent = "  ".repeat(buildContext.depth);
      logger.debug(
        indent +
          "consumed trailing trivia: " +
          trailingTrivia.map((trivia) => trivia.text.replaceAll("\n", "\\n"))
            .join(
              ", ",
            ),
      );
      node.trailingTrivia = trailingTrivia;
    }
  }

  // Check if we are at end of siblings and need to move back to parent
  if (buildContext.isEndOfSiblings) {
    buildContext.isEndOfSiblings = false;
    if (!cursor.nextSibling()) {
      indent = "  ".repeat(buildContext.depth);
      logger.debug(indent + "no next sibling, moving back to parent");
      if (cursor.parent()) {
        indent = "  ".repeat(buildContext.depth);
        logger.debug(indent + "now at parent: " + cursor.type.name);

        buildContext.isEndOfSiblings = true;
        let hasSibling = cursor.nextSibling();
        // move to next non-whitespace sibling
        while (hasSibling) {
          if (cursor.type.name !== "Whitespace") {
            buildContext.isEndOfSiblings = false;
            break;
          }
          // skip whitespace siblings
          hasSibling = cursor.nextSibling();
        }
        if (buildContext.isEndOfSiblings) {
          logger.debug(indent + "no next sibling at parent, end of siblings");
        } else {
          logger.debug(indent + "now at sibling: " + cursor.type.name);
        }
      } else {
        buildContext.isEndOfSiblings = true;
      }
    }
  }

  return node;
}
