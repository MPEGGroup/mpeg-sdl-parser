import { Text } from "@codemirror/state";
import { TreeCursor } from "@lezer/common";
import type { Trivia } from "../node/Trivia.ts";
import { getLocationFromTextPosition } from "../../util/locationUtils.ts";
import type { BuildContext } from "../build/BuildContext.ts";

// Generated by Lezer from the SDL grammar
import { Comment, Whitespace } from "../../lezer/parser.terms.ts";

function getCommentTrivia(cursor: TreeCursor, text: Text): Trivia {
  return {
    text: text.sliceString(cursor.from, cursor.to),
    location: getLocationFromTextPosition(text, cursor.from),
  };
}

function getBlankLineTrivia(cursor: TreeCursor, text: Text): Trivia {
  return {
    text: "\n",
    location: getLocationFromTextPosition(text, cursor.from),
  };
}

/**
 * Iterate through the syntax tree and convert comments or whitespace to Trivia
 * until a non-comment or non-whitespace parse node is found.
 */
export function consumeTrivia(
  buildContext: BuildContext,
): Trivia[] {
  const { cursor, text } = buildContext;
  const trivia: Trivia[] = [];

  let noSibling = true;

  do {
    // Save comments
    if (cursor.type.id === Comment) {
      trivia.push(getCommentTrivia(cursor, text));
    } // Skip whitespace except for multiple new lines which are collapsed into a single blank line trivia
    else if (cursor.type.id === Whitespace) {
      const whitespace = text.sliceString(cursor.from, cursor.to);
      const newLineCount = (whitespace.match(/\n/g) || []).length;
      if (newLineCount > 1) {
        trivia.push(getBlankLineTrivia(cursor, text));
      }
    } // Stop at the first non-comment, non-whitespace node
    else {
      noSibling = false;
      break;
    }
  } while (cursor.nextSibling());

  if (noSibling) {
    buildContext.isEndOfSiblings = true;
  }

  return trivia;
}
