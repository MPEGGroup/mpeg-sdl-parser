import type { Tree } from "@lezer/common";
import { Text } from "@codemirror/state";
import type { SdlStringInput } from "../lezer/sdl-string-input.ts";
import type { Specification } from "./node/specification.ts";
import { debugEnabled } from "../util/logger.ts";
import type { NodeHandler } from "./visitor/node-handler.ts";
import { TraversingVisitor } from "./visitor/traversing-visitor.ts";
import { InternalParseError } from "../parse-error.ts";
import type { BuildContext } from "./build/build-context.ts";
import type { RequiredNode } from "./util/types.ts";
import { fetchRequiredNode } from "./util/fetch-node.ts";
import { NodeKind } from "./node/enum/node-kind.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../lezer/parser.terms.ts";

/**
 * Process the SDL parse tree and return an abstract syntax tree.
 *
 * @param parseTree The parse `Tree` generated from the SDL source.
 * @param sdlStringInput The SDL source text as an `SdlStringInput`.
 * @param lenient If true, the AST construction will be lenient and create error tokens and nodes for parse errors in the parse tree.
 */
export function buildAst(
  parseTree: Tree,
  sdlStringInput: SdlStringInput,
  lenient = false,
): RequiredNode<Specification> {
  const text = Text.of(
    sdlStringInput.read(0, sdlStringInput.length).split("\n"),
  );
  const cursor = parseTree.cursor();
  const buildContext: BuildContext = {
    cursor,
    text,
    lenient,
    depth: 0,
    nextNodes: [],
  };

  // check the root node is a Specification
  if (cursor.type.id !== TokenTypeId.Specification) {
    throw new InternalParseError(
      `Expected start node to be a Specification, but found ${cursor.type.name}.`,
    );
  }

  const specification = fetchRequiredNode<Specification>(
    buildContext,
    NodeKind.SPECIFICATION,
  );

  if (buildContext.depth !== 0) {
    throw new InternalParseError(
      `Expected final build context depth to be 0, but found ${buildContext.depth}.`,
    );
  }

  if (!specification) {
    throw new InternalParseError(
      `Expected to parse a Specification node, but none was found.`,
    );
  }

  if (cursor.type.id !== TokenTypeId.Specification) {
    throw new InternalParseError(
      `Expected final node to be a Specification, but found ${cursor.type.name}.`,
    );
  }

  if (debugEnabled) {
    const dummyNodeHandler: NodeHandler = {
      beforeVisit: () => {},
      visit: () => {},
      afterVisit: () => {},
    };
    const traversingVisitor = new TraversingVisitor(dummyNodeHandler);
    traversingVisitor.visit(specification);
  }

  return specification;
}
