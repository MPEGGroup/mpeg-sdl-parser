import { TokenKind } from "../../node/enum/token-kind.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../../../lezer/parser.terms.ts";
import { InternalParseError } from "../../../parse-error.ts";

export const tokenKindByTokenTypeId: Map<number, TokenKind> = new Map();

/**
 * Map parsed token type ID to AST token type enum.
 * Exhaustive switch statement to ensure all token type IDs are handled.
 */
Object.values(TokenTypeId).forEach((tokenTypeId) => {
  switch (tokenTypeId) {
    case TokenTypeId._break:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.BREAK);
      break;
    case TokenTypeId._case:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.CASE);
      break;
    case TokenTypeId._class:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.CLASS);
      break;
    case TokenTypeId._const:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.CONST);
      break;
    case TokenTypeId._default:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.DEFAULT);
      break;
    case TokenTypeId._do:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.DO);
      break;
    case TokenTypeId._else:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ELSE);
      break;
    case TokenTypeId._extends:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.EXTENDS);
      break;
    case TokenTypeId._for:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.FOR);
      break;
    case TokenTypeId._if:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.IF);
      break;
    case TokenTypeId._switch:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.SWITCH);
      break;
    case TokenTypeId._while:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.WHILE);
      break;
    case TokenTypeId.abstract:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ABSTRACT);
      break;
    case TokenTypeId.Addition:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ADDITION);
      break;
    case TokenTypeId.AlignmentBitCount8:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ALIGNMENT_BIT_COUNT_8);
      break;
    case TokenTypeId.AlignmentBitCount16:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ALIGNMENT_BIT_COUNT_16);
      break;
    case TokenTypeId.AlignmentBitCount32:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ALIGNMENT_BIT_COUNT_32);
      break;
    case TokenTypeId.AlignmentBitCount64:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ALIGNMENT_BIT_COUNT_64);
      break;
    case TokenTypeId.AlignmentBitCount128:
      tokenKindByTokenTypeId.set(
        tokenTypeId,
        TokenKind.ALIGNMENT_BIT_COUNT_128,
      );
      break;
    case TokenTypeId.aligned:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ALIGNED);
      break;
    case TokenTypeId.Assignment:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.ASSIGNMENT);
      break;
    case TokenTypeId.base64string:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.BASE64_STRING);
      break;
    case TokenTypeId.Base64StringLiteralCharacters:
      tokenKindByTokenTypeId.set(
        tokenTypeId,
        TokenKind.BASE64_STRING_LITERAL_CHARACTERS,
      );
      break;
    case TokenTypeId.BinaryLiteral:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.BINARY_LITERAL);
      break;
    case TokenTypeId.bit:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.BIT);
      break;
    case TokenTypeId.BitwiseAnd:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.BITWISE_AND);
      break;
    case TokenTypeId.BitwiseOr:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.BITWISE_OR);
      break;
    case TokenTypeId.BitwiseShiftLeft:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.BITWISE_SHIFT_LEFT);
      break;
    case TokenTypeId.BitwiseShiftRight:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.BITWISE_SHIFT_RIGHT);
      break;
    case TokenTypeId.CloseBrace:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.CLOSE_BRACE);
      break;
    case TokenTypeId.CloseBracket:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.CLOSE_BRACKET);
      break;
    case TokenTypeId.CloseParenthesis:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.CLOSE_PARENTHESIS);
      break;
    case TokenTypeId.Colon:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.COLON);
      break;
    case TokenTypeId.Comma:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.COMMA);
      break;
    case TokenTypeId.computed:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.COMPUTED);
      break;
    case TokenTypeId.DecimalLiteral:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.DECIMAL_LITERAL);
      break;
    case TokenTypeId.Division:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.DIVISION);
      break;
    case TokenTypeId.DoubleQuote:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.DOUBLE_QUOTE);
      break;
    case TokenTypeId.expandable:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.EXPANDABLE);
      break;
    case TokenTypeId.float:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.FLOAT);
      break;
    case TokenTypeId.FloatingPointLiteral:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.FLOATING_POINT_LITERAL);
      break;
    case TokenTypeId.HexadecimalLiteral:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.HEXADECIMAL_LITERAL);
      break;
    case TokenTypeId.Identifier:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.IDENTIFIER);
      break;
    case TokenTypeId.int:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.INT);
      break;
    case TokenTypeId.IntegerLiteral:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.INTEGER_LITERAL);
      break;
    case TokenTypeId.legacy:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.LEGACY);
      break;
    case TokenTypeId.lengthof:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.LENGTHOF);
      break;
    case TokenTypeId.LogicalAnd:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.LOGICAL_AND);
      break;
    case TokenTypeId.LogicalOr:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.LOGICAL_OR);
      break;
    case TokenTypeId.LookAhead:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.LOOK_AHEAD);
      break;
    case TokenTypeId.map:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.MAP);
      break;
    case TokenTypeId.Modulus:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.MODULUS);
      break;
    case TokenTypeId.MultipleCharacterLiteralCharacters:
      tokenKindByTokenTypeId.set(
        tokenTypeId,
        TokenKind.MULTIPLE_CHARACTER_LITERAL_CHARACTERS,
      );
      break;
    case TokenTypeId.Multiplication:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.MULTIPLICATION);
      break;
    case TokenTypeId.OpenBrace:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.OPEN_BRACE);
      break;
    case TokenTypeId.OpenBracket:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.OPEN_BRACKET);
      break;
    case TokenTypeId.OpenParenthesis:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.OPEN_PARENTHESIS);
      break;
    case TokenTypeId.Period:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.PERIOD);
      break;
    case TokenTypeId.PostfixDecrement:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.POSTFIX_DECREMENT);
      break;
    case TokenTypeId.PostfixIncrement:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.POSTFIX_INCREMENT);
      break;
    case TokenTypeId.RangeOperator:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.RANGE_OPERATOR);
      break;
    case TokenTypeId.reserved:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.RESERVED);
      break;
    case TokenTypeId.RelationalEqual:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.RELATIONAL_EQUAL);
      break;
    case TokenTypeId.RelationalGreaterThan:
      tokenKindByTokenTypeId.set(
        tokenTypeId,
        TokenKind.RELATIONAL_GREATER_THAN,
      );
      break;
    case TokenTypeId.RelationalGreaterThanOrEqual:
      tokenKindByTokenTypeId.set(
        tokenTypeId,
        TokenKind.RELATIONAL_GREATER_THAN_OR_EQUAL,
      );
      break;
    case TokenTypeId.RelationalLessThan:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.RELATIONAL_LESS_THAN);
      break;
    case TokenTypeId.RelationalLessThanOrEqual:
      tokenKindByTokenTypeId.set(
        tokenTypeId,
        TokenKind.RELATIONAL_LESS_THAN_OR_EQUAL,
      );
      break;
    case TokenTypeId.RelationalNotEqual:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.RELATIONAL_NOT_EQUAL);
      break;
    case TokenTypeId.Semicolon:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.SEMICOLON);
      break;
    case TokenTypeId.SingleQuote:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.SINGLE_QUOTE);
      break;
    case TokenTypeId.Subtraction:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.SUBTRACTION);
      break;
    case TokenTypeId.UnaryNegation:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.UNARY_NEGATION);
      break;
    case TokenTypeId.UnaryPlus:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.UNARY_PLUS);
      break;
    case TokenTypeId.unsigned:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.UNSIGNED);
      break;
    case TokenTypeId.utf16string:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.UTF16_STRING);
      break;
    case TokenTypeId.utf8list:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.UTF8_LIST);
      break;
    case TokenTypeId.utf8string:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.UTF8_STRING);
      break;
    case TokenTypeId.utfstring:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.UTF_STRING);
      break;
    case TokenTypeId.UtfPrefix:
      tokenKindByTokenTypeId.set(tokenTypeId, TokenKind.UTF_PREFIX);
      break;
    case TokenTypeId.UtfStringLiteralCharacters:
      tokenKindByTokenTypeId.set(
        tokenTypeId,
        TokenKind.UTF_STRING_LITERAL_CHARACTERS,
      );
      break;

    // Parser tokens that do not map to AST TokenKinds
    case TokenTypeId.AlignedModifier:
    case TokenTypeId.AggregateOutputValue:
    case TokenTypeId.ArrayDefinition:
    case TokenTypeId.AssignmentExpression:
    case TokenTypeId.ArrayElementAccess:
    case TokenTypeId.Base64StringLiteral:
    case TokenTypeId.BinaryExpression:
    case TokenTypeId.BitModifier:
    case TokenTypeId.CaseClause:
    case TokenTypeId.ClassDefinition:
    case TokenTypeId.ClassDeclaration:
    case TokenTypeId.ClassId:
    case TokenTypeId.ClassIdRange:
    case TokenTypeId.ClassMemberAccess:
    case TokenTypeId.Comment:
    case TokenTypeId.CompoundStatement:
    case TokenTypeId.ComputedArrayDefinition:
    case TokenTypeId.ComputedElementaryTypeDefinition:
    case TokenTypeId.DefaultClause:
    case TokenTypeId.DoStatement:
    case TokenTypeId.ElementaryType:
    case TokenTypeId.ElementaryTypeDefinition:
    case TokenTypeId.ElementaryTypeOutputValue:
    case TokenTypeId.ExpandableModifier:
    case TokenTypeId.ExplicitArrayDimension:
    case TokenTypeId.ExpressionStatement:
    case TokenTypeId.ExtendedClassIdRange:
    case TokenTypeId.ExtendsModifier:
    case TokenTypeId.ForStatement:
    case TokenTypeId.IfStatement:
    case TokenTypeId.ImplicitArrayDimension:
    case TokenTypeId.LengthAttribute:
    case TokenTypeId.LengthofExpression:
    case TokenTypeId.MapDeclaration:
    case TokenTypeId.MapDefinition:
    case TokenTypeId.MapEntry:
    case TokenTypeId.MultipleCharacterLiteral:
    case TokenTypeId.Parameter:
    case TokenTypeId.ParameterList:
    case TokenTypeId.ParameterValueList:
    case TokenTypeId.PartialArrayDimension:
    case TokenTypeId.Specification:
    case TokenTypeId.StringDefinition:
    case TokenTypeId.SwitchStatement:
    case TokenTypeId.UnaryExpression:
    case TokenTypeId.UtfStringLiteral:
    case TokenTypeId.WhileStatement:
    case TokenTypeId.Whitespace:
      break;
    default: {
      const exhaustiveCheck: never = tokenTypeId;
      throw new InternalParseError(
        "Unreachable code reached, tokenTypeId == " + exhaustiveCheck,
      );
    }
  }
});

// Add mapping for unknown token
tokenKindByTokenTypeId.set(0, TokenKind.ERROR_UNKNOWN_TOKEN);
