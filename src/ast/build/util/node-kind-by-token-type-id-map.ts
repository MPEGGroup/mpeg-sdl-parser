import { NodeKind } from "../../node/enum/node-kind.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../../../lezer/parser.terms.ts";

export const nodeKindByTokenTypeId: Map<number, NodeKind> = new Map();

/**
 * Map parsed token type ID to AST token type enum.
 * Exhaustive switch statement to ensure all token type IDs are handled.
 */
Object.values(TokenTypeId).forEach((tokenTypeId) => {
  switch (tokenTypeId) {
    case TokenTypeId.AlignedModifier:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.ALIGNED_MODIFIER);
      break;
    case TokenTypeId.AggregateOutputValue:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.AGGREGATE_OUTPUT_VALUE);
      break;
    case TokenTypeId.ArrayDefinition:
    case TokenTypeId.ClassDefinition:
    case TokenTypeId.ClassDeclaration:
    case TokenTypeId.CompoundStatement:
    case TokenTypeId.ComputedArrayDefinition:
    case TokenTypeId.ComputedElementaryTypeDefinition:
    case TokenTypeId.DoStatement:
    case TokenTypeId.ElementaryTypeDefinition:
    case TokenTypeId.ExpressionStatement:
    case TokenTypeId.ForStatement:
    case TokenTypeId.IfStatement:
    case TokenTypeId.MapDeclaration:
    case TokenTypeId.MapDefinition:
    case TokenTypeId.StringDefinition:
    case TokenTypeId.SwitchStatement:
    case TokenTypeId.WhileStatement:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.STATEMENT);
      break;
    case TokenTypeId.AssignmentExpression:
    case TokenTypeId.BinaryExpression:
    case TokenTypeId.LengthofExpression:
    case TokenTypeId.UnaryExpression:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.EXPRESSION);
      break;
    case TokenTypeId.ArrayElementAccess:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.ARRAY_ELEMENT_ACCESS);
      break;
    case TokenTypeId.Base64StringLiteral:
    case TokenTypeId.UtfStringLiteral:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.STRING_LITERAL);
      break;
    case TokenTypeId.BitModifier:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.BIT_MODIFIER);
      break;
    case TokenTypeId.CaseClause:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.CASE_CLAUSE);
      break;
    case TokenTypeId.ClassId:
    case TokenTypeId.ClassIdRange:
    case TokenTypeId.ExtendedClassIdRange:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.CLASS_ID);
      break;
    case TokenTypeId.ClassMemberAccess:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.CLASS_MEMBER_ACCESS);
      break;
    case TokenTypeId.DefaultClause:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.DEFAULT_CLAUSE);
      break;
    case TokenTypeId.ElementaryType:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.ELEMENTARY_TYPE);
      break;
    case TokenTypeId.ElementaryTypeOutputValue:
      nodeKindByTokenTypeId.set(
        tokenTypeId,
        NodeKind.ELEMENTARY_TYPE_OUTPUT_VALUE,
      );
      break;
    case TokenTypeId.ExpandableModifier:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.EXPANDABLE_MODIFIER);
      break;
    case TokenTypeId.ExplicitArrayDimension:
    case TokenTypeId.ImplicitArrayDimension:
    case TokenTypeId.PartialArrayDimension:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.ARRAY_DIMENSION);
      break;
    case TokenTypeId.ExtendsModifier:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.EXTENDS_MODIFIER);
      break;
    case TokenTypeId.LengthAttribute:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.LENGTH_ATTRIBUTE);
      break;
    case TokenTypeId.MapEntry:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.MAP_ENTRY);
      break;
    case TokenTypeId.MultipleCharacterLiteral:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.NUMBER_LITERAL);
      break;
    case TokenTypeId.Parameter:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.PARAMETER);
      break;
    case TokenTypeId.ParameterList:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.PARAMETER_LIST);
      break;
    case TokenTypeId.ParameterValueList:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.PARAMETER_VALUE_LIST);
      break;
    case TokenTypeId.Specification:
      nodeKindByTokenTypeId.set(tokenTypeId, NodeKind.SPECIFICATION);
      break;

    // Parser tokens that do not map to AST NodeKinds
    case TokenTypeId._break:
    case TokenTypeId._case:
    case TokenTypeId._class:
    case TokenTypeId._const:
    case TokenTypeId._default:
    case TokenTypeId._do:
    case TokenTypeId._else:
    case TokenTypeId._extends:
    case TokenTypeId._for:
    case TokenTypeId._if:
    case TokenTypeId._switch:
    case TokenTypeId._while:
    case TokenTypeId.abstract:
    case TokenTypeId.Addition:
    case TokenTypeId.AlignmentBitCount8:
    case TokenTypeId.AlignmentBitCount16:
    case TokenTypeId.AlignmentBitCount32:
    case TokenTypeId.AlignmentBitCount64:
    case TokenTypeId.AlignmentBitCount128:
    case TokenTypeId.aligned:
    case TokenTypeId.Assignment:
    case TokenTypeId.base64string:
    case TokenTypeId.Base64StringLiteralCharacters:
    case TokenTypeId.BinaryLiteral:
    case TokenTypeId.bit:
    case TokenTypeId.BitwiseAnd:
    case TokenTypeId.BitwiseOr:
    case TokenTypeId.BitwiseShiftLeft:
    case TokenTypeId.BitwiseShiftRight:
    case TokenTypeId.CloseBrace:
    case TokenTypeId.CloseBracket:
    case TokenTypeId.CloseParenthesis:
    case TokenTypeId.Colon:
    case TokenTypeId.Comma:
    case TokenTypeId.Comment:
    case TokenTypeId.computed:
    case TokenTypeId.DecimalLiteral:
    case TokenTypeId.Division:
    case TokenTypeId.DoubleQuote:
    case TokenTypeId.expandable:
    case TokenTypeId.float:
    case TokenTypeId.FloatingPointLiteral:
    case TokenTypeId.HexadecimalLiteral:
    case TokenTypeId.Identifier:
    case TokenTypeId.int:
    case TokenTypeId.IntegerLiteral:
    case TokenTypeId.legacy:
    case TokenTypeId.lengthof:
    case TokenTypeId.LogicalAnd:
    case TokenTypeId.LogicalOr:
    case TokenTypeId.LookAhead:
    case TokenTypeId.map:
    case TokenTypeId.Modulus:
    case TokenTypeId.MultipleCharacterLiteralCharacters:
    case TokenTypeId.Multiplication:
    case TokenTypeId.OpenBrace:
    case TokenTypeId.OpenBracket:
    case TokenTypeId.OpenParenthesis:
    case TokenTypeId.Period:
    case TokenTypeId.PostfixDecrement:
    case TokenTypeId.PostfixIncrement:
    case TokenTypeId.RangeOperator:
    case TokenTypeId.reserved:
    case TokenTypeId.RelationalEqual:
    case TokenTypeId.RelationalGreaterThan:
    case TokenTypeId.RelationalGreaterThanOrEqual:
    case TokenTypeId.RelationalLessThan:
    case TokenTypeId.RelationalLessThanOrEqual:
    case TokenTypeId.RelationalNotEqual:
    case TokenTypeId.Semicolon:
    case TokenTypeId.SingleQuote:
    case TokenTypeId.Subtraction:
    case TokenTypeId.UnaryNegation:
    case TokenTypeId.UnaryPlus:
    case TokenTypeId.unsigned:
    case TokenTypeId.utf16string:
    case TokenTypeId.utf8list:
    case TokenTypeId.utf8string:
    case TokenTypeId.utfstring:
    case TokenTypeId.UtfPrefix:
    case TokenTypeId.UtfStringLiteralCharacters:
    case TokenTypeId.Whitespace:
      break;
    default: {
      const exhaustiveCheck: never = tokenTypeId;
      throw new InternalParseError(
        "Unreachable code reached, tokenTypeId == " + exhaustiveCheck,
      );
    }
  }
});
