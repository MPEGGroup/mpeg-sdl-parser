import { Text } from "@codemirror/state";
import { TreeCursor } from "@lezer/common";
import type { Trivia } from "../../node/trivia.ts";
import { getLocationFromTextPosition } from "../../../util/location-utils.ts";
import type { BuildContext } from "../util/build-context.ts";
import getLogger from "../../../util/logger.ts";

// Generated by Lezer from the SDL grammar
import { Comment, Whitespace } from "../../../lezer/parser.terms.ts";

const logger = getLogger("consumeTrivia");

function getCommentTrivia(cursor: TreeCursor, text: Text): Trivia {
  return {
    text: text.sliceString(cursor.from, cursor.to),
    location: getLocationFromTextPosition(text, cursor.from),
  };
}

function getBlankLineTrivia(cursor: TreeCursor, text: Text): Trivia {
  return {
    text: "\n",
    location: getLocationFromTextPosition(text, cursor.from),
  };
}

/**
 * Iterate through the syntax tree and convert comments or whitespace to Trivia
 * until a non-comment or non-whitespace parse node is found.
 */
export function consumeTrivia(
  buildContext: BuildContext,
  isTrailing: boolean,
): Trivia[] {
  const { cursor, text } = buildContext;
  const currentState =
    buildContext.stateStack[buildContext.stateStack.length - 1];

  if (currentState.isEndOfSiblings) {
    return [];
  }

  const trivia: Trivia[] = [];

  let noSibling = true;

  do {
    // Save comments
    if (cursor.type.id === Comment) {
      trivia.push(getCommentTrivia(cursor, text));

      // If trailing, stop after first comment
      if (isTrailing) {
        // advance the cursor as we consumed the comment
        noSibling = !cursor.nextSibling();
        break;
      }
    } // Skip whitespace except for multiple new lines which are collapsed into a single blank line trivia
    else if (cursor.type.id === Whitespace) {
      const whitespace = text.sliceString(cursor.from, cursor.to);
      const newLineCount = (whitespace.match(/\n/g) || []).length;

      // If trailing, stop at first line break
      if (isTrailing && (newLineCount > 0)) {
        noSibling = false;
        break;
      }

      if (newLineCount > 1) {
        trivia.push(getBlankLineTrivia(cursor, text));
      }
    } // Otherwise stop at the first non-comment, non-whitespace node
    else if (
      (cursor.type.id !== Comment) &&
      (cursor.type.id !== Whitespace)
    ) {
      noSibling = false;
      break;
    }
  } while (cursor.nextSibling());

  currentState.isEndOfSiblings = noSibling;

  if (trivia.length > 0) {
    logger.debug(
      currentState.indent +
        `consumed ${isTrailing ? "trailing" : "leading"} trivia: ` +
        trivia.map((triviaEntry) => triviaEntry.text.replaceAll("\n", "\\n"))
          .join(
            ", ",
          ),
    );
  }

  return trivia;
}
