import { describe, expect, test } from "bun:test";
import { createLenientSdlParser } from "../../src/lezer/create-sdl-parser.ts";
import { SdlStringInput } from "../../src/lezer/sdl-string-input.ts";
import { getExpectedTokenTypeIds } from "../../src/completion/get-expected-token-type-ids.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../../src/lezer/parser.terms.ts";

const lenientSdlParser = createLenientSdlParser();

describe("getExpectedTokenTypeIds Tests", () => {
  test("Test missing length attribute", () => {
    const sdlStringInput = new SdlStringInput("class A { bit b; }");
    const parseTree = lenientSdlParser.parse(sdlStringInput);
    const cursor = parseTree.cursor();
    do {
      if (cursor.type.isError) {
        break;
      }
    } while (cursor.next());

    const tokenTypeIds = getExpectedTokenTypeIds(cursor);

    expect(tokenTypeIds).toEqual([TokenTypeId.LengthAttribute]);
  });

  test("Test duplicate identifier", () => {
    const sdlStringInput = new SdlStringInput(
      "class A {if (f oo) {bit(8) c;}}",
    );
    const parseTree = lenientSdlParser.parse(sdlStringInput);
    const cursor = parseTree.cursor();
    do {
      if (cursor.type.isError) {
        break;
      }
    } while (cursor.next());

    const tokenTypeIds = getExpectedTokenTypeIds(cursor);

    expect(tokenTypeIds).toEqual([
      TokenTypeId.Multiplication,
      TokenTypeId.Division,
      TokenTypeId.Modulus,
      TokenTypeId.Addition,
      TokenTypeId.Subtraction,
      TokenTypeId.BitwiseShiftLeft,
      TokenTypeId.BitwiseShiftRight,
      TokenTypeId.RelationalLessThan,
      TokenTypeId.RelationalLessThanOrEqual,
      TokenTypeId.RelationalGreaterThan,
      TokenTypeId.RelationalGreaterThanOrEqual,
      TokenTypeId.RelationalEqual,
      TokenTypeId.RelationalNotEqual,
      TokenTypeId.BitwiseAnd,
      TokenTypeId.BitwiseOr,
      TokenTypeId.LogicalAnd,
      TokenTypeId.LogicalOr,
    ]);
  });
});
