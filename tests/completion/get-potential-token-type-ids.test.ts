import { describe, test } from "bun:test";
import { testPotentialTokenTypeIdsScenario } from "./test-potential-token-type-ids-scenario.ts";

// Generated by Lezer from the SDL grammar
import * as TokenTypeId from "../../src/lezer/parser.terms.ts";

describe("getPotentialTokenTypeIds Tests", () => {
  test("Test missing length attribute expected token type scenario", () => {
    testPotentialTokenTypeIdsScenario(
      "class A { bit b; }",
      [TokenTypeId.LengthAttribute],
    );
  });

  test("Test duplicate identifier expected token type scenario", () => {
    testPotentialTokenTypeIdsScenario(
      "class A {if (f oo) {bit(8) c;}}",
      [
        TokenTypeId.Multiplication,
        TokenTypeId.Division,
        TokenTypeId.Modulus,
        TokenTypeId.Addition,
        TokenTypeId.Subtraction,
        TokenTypeId.BitwiseShiftLeft,
        TokenTypeId.BitwiseShiftRight,
        TokenTypeId.RelationalLessThan,
        TokenTypeId.RelationalLessThanOrEqual,
        TokenTypeId.RelationalGreaterThan,
        TokenTypeId.RelationalGreaterThanOrEqual,
        TokenTypeId.RelationalEqual,
        TokenTypeId.RelationalNotEqual,
        TokenTypeId.BitwiseAnd,
        TokenTypeId.BitwiseOr,
        TokenTypeId.LogicalAnd,
        TokenTypeId.LogicalOr,
      ].sort((a, b) => a - b),
    );
  });

  test("Test complex expected token type scenario", () => {
    testPotentialTokenTypeIdsScenario(
      "class A {if (a b == 0b01 || c == 0b11) {bit(8) c;}}",
      [
        TokenTypeId.CloseParenthesis,
        TokenTypeId.Multiplication,
        TokenTypeId.Division,
        TokenTypeId.Modulus,
        TokenTypeId.Addition,
        TokenTypeId.Subtraction,
        TokenTypeId.BitwiseShiftLeft,
        TokenTypeId.BitwiseShiftRight,
        TokenTypeId.RelationalLessThan,
        TokenTypeId.RelationalLessThanOrEqual,
        TokenTypeId.RelationalGreaterThan,
        TokenTypeId.RelationalGreaterThanOrEqual,
        TokenTypeId.RelationalEqual,
        TokenTypeId.RelationalNotEqual,
        TokenTypeId.BitwiseAnd,
        TokenTypeId.BitwiseOr,
        TokenTypeId.LogicalAnd,
        TokenTypeId.LogicalOr,
      ].sort((a, b) => a - b),
    );
  });

  test("Test global scope expected token type scenario", () => {
    testPotentialTokenTypeIdsScenario(
      "",
      [
        TokenTypeId.ClassDeclaration,
        TokenTypeId.ComputedElementaryTypeDefinition,
        TokenTypeId.MapDeclaration,
      ].sort((a, b) => a - b),
    );
  });
});
