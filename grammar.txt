/* Syntactic description language EBNF syntax: https://www.w3.org/TR/xml/#sec-notation */
/* References are either to sub-clauses or rules appearing in 14496-34 */
/* Lines indented by 4 spaces have been wrapped from the previous line */

/* 5.1 Character set */

non_zero_digit_character ::= [1-9]
digit_character ::= 0 | non_zero_digit_character
latin_character ::= [a-zA-Z]
graphic_character ::= '!' | '%' | '&' | ',' | '.' | '/' | ';' | '<' | '>' | '\' | '_' | '{' | '}' |
    '~' | '"' | '#' | "'" | '(' | ')' | '*' | '+' | '-' | ':' | '=' | '?' | '[' | ']' | '^' | '|'
basic_character ::= digit_character | latin_character | graphic_character

/* 5.4 Comments */

/* Rule S.1: Comments */

comment ::= '//' basic_character*

/* 5.5 Identifiers */

identifier_character ::= digit_character | latin_character | '_'

/* An identifier must include at least one alphabetic character.  */
identifier ::= identifier_character* latin_character identifier_character*

/* 5.6 Punctuators */

open_parenthesis ::= '('
close_parenthesis ::= ')'
open_brace ::= '{'
close_brace ::= '}'
open_bracket ::= '['
close_bracket ::= ']'
colon ::= ':'
semicolon ::= ';'
comma ::= ','
double_quote ::= '"'

/* 5.7 Keywords */

abstract ::= 'abstract'
aligned ::= 'aligned'
base64string ::= 'base64string'
bit ::= 'bit'
break ::= 'break'
case ::= 'case'
class ::= 'class'
const ::= 'const'
default ::= 'default'
do ::= 'do'
else ::= 'else'
expandable ::= 'expandable'
extends ::= 'extends'
float ::= 'float'
for ::= 'for'
if ::= 'if'
int ::= 'int'
lengthof ::= 'lengthof'
map ::= 'map'
switch ::= 'switch'
unsigned ::= 'unsigned'
utf8string ::= 'utf8string'
utf8list ::= 'utf8list'
utfstring ::= 'utfstring'
while ::= 'while'

/* 5.8 Operators */

class_member_access ::= '.'
/* [] array element access defined as part of array_element_access_expression */
postfix_increment ::= '++'
postfix_decrement ::= '--'
unary_plus ::= '+'
unary_negation ::= '-'
multiplication ::= '*'
division ::= '/'
modulus ::= '%'
addition ::= '+'
subtraction ::= '-'
bitwise_shift_left ::= '<<'
bitwise_shift_right ::= '>>'
relational_less_than ::= '<'
relational_less_than_or_equal ::= '<='
relational_greater_than ::= '>'
relational_greater_than_or_equal ::= '>='
relational_equal ::= '=='
relational_not_equal ::= '!='
bitwise_and ::= '&'
bitwise_or ::= '|'
logical_and ::= '&&'
logical_or ::= '||'
assignment ::= '='

postfix_operator ::= postfix_increment | postfix_decrement
arithmetic_operator ::= multiplication | division | modulus | addition | subtraction
shift_operator ::= bitwise_shift_left | bitwise_shift_right
comparison_operator ::= relational_less_than | relational_less_than_or_equal | relational_greater_than |
    relational_greater_than_or_equal | relational_equal | relational_not_equal
binary_operator ::= bitwise_and | bitwise_or
logical_operator ::= logical_and | logical_or

/* 5.9 Expressions and evaluation */

unary_expression ::= (identifier | number_literal | lengthof_expression |
	class_member_access_expression | array_element_access_expression | open_parenthesis
	expression close_parenthesis) postfix_operator?
constant_expression ::= number_literal | string_literal
expression ::= unary_expression ((arithmetic_operator | shift_operator | comparison_operator |
    binary_operator | logical_operator) unary_expression)*
assignment_target ::= identifier | class_member_access_expression | array_access_expression
assignment_expression ::= assignment_target assignment expression

/* 5.10 Statements */

/* A statement consists of an expression followed by a semicolon */
expression_statement ::= (expression | assignment_expression) semicolon

/* Block scoping */
compound_statement ::= open_brace statement* close_brace

statement ::= expression_statement | compound_statement | elementary_type_definition
  | map_declaration | map_definition | string_definition
  | class_declaration | class_definition | array_definition
  | non_parsable_elementary_type_definition | non_parsable_array_definition
  | if_statement | switch_statement | for_statement | do_statement | while_statement

/* 5.11 Built-in operators */

/* Rule O.1: lengthof() Operator */

lengthof_expression ::= lengthof open_parenthesis (identifier |
	class_member_access_expression | array_element_access_expression) close_parenthesis

/* Rule O.2: Range operator */

range_operator ::= '..'

/* Rule O.3: Class member access operator */

class_member_access_expression ::= identifier (class_member_access identifier)+

/* 5.14 Binary literal values */

/* Rule S.2: Binary literal value */

binary_character ::= 0 | 1
binary_character_string ::= binary_character*
four_binary_characters ::= binary_character binary_character binary_character binary_character
one_to_four_binary_characters ::= binary_character binary_character? binary_character? binary_character?
period_separated_binary_character_string ::= four_binary_characters ('.'
	four_binary_characters)+ ('.' one_to_four_binary_characters)?

binary_literal ::= '0b' (period_separated_binary_character_string | binary_character_string )

/* 5.15 Hexadecimal literal values */

/* Rule S.3: Hexadecimal literal value */

hexadecimal_character ::= [0-9A-F]
hexadecimal_character_string ::= hexadecimal_character*
four_hexadecimal_characters ::= hexadecimal_character hexadecimal_character
	hexadecimal_character hexadecimal_character
one_to_four_hexadecimal_characters ::= hexadecimal_character hexadecimal_character?
	hexadecimal_character? hexadecimal_character?
period_separated_hexadecimal_character_string ::= four_hexadecimal_characters ('.'
	four_hexadecimal_characters)+ ('.' one_to_four_hexadecimal_characters)?

hexadecimal_literal ::= '0x' (period_separated_hexadecimal_character_string | hexadecimal_character_string)

/* 5.16 Integer, decimal and floating-point literal values

positive_integer ::= non_zero_digit_character digit_character*

integer_literal ::= 0 | ((unary_plus | unary_negation)? positive_integer)
decimal_literal ::= integer_literal '.' digit_character*
floating_point_literal ::= (unary_plus | unary_negation)? (0 | positive_integer) '.' digit_character* 'e'
	integer_literal

number_literal ::= binary_literal | hexadecimal_literal | integer_literal |
	 decimal_literal | floating_point_literal

/* 5.17 String literal values */

literal_character ::= (basic_character - double_quote - '\') | ('\' double_quote) | '\\'
utf_literal_character ::= ([#x0000-#x10FFFF] - double_quote - '\' - #xFEFF) | ('\' double_quote) | '\\'
universal_character_name ::= ('\u' four_hexadecimal_characters)
    ('\U' four_hexadecimal_characters four_hexadecimal_characters)

basic_string_literal ::= double_quote literal_character* double_quote
utf8_string_literal ::= 'u8' double_quote (utf_literal_character | universal_character_name)* double_quote
utf16_string_literal ::= 'u' double_quote (utf_literal_character | universal_character_name)* double_quote

string_literal ::= basic_string_literal | utf8_string_literal | utf16_string_literal

/* 5.18 Scope */

/* global scope and entry point: only comments, */
/* class declarations and class definitions are allowed */

Specification ::= (class_declaration | class_definition | comment | (class_declaration comment) |
    (class_definition comment))+

/* 6.2 Constant-length direct representation bit fields */

/* Rule E.1: Elementary data types */

aligned_modifier ::= aligned (open_bracket ('8' | '16' | '32' | '64' | '128')
	close_bracket)?

/* double is a legacy alias for the keyword float. */
/* The use of the keyword double is no longer recommended. */
type ::= int | unsigned int | float | bit | double

length_attribute ::= open_parenthesis expression close_parenthesis

/* Rule E.2: Look-ahead parsing */

/* 6.3 Variable length direct representation bit fields */

elementary_type_definition ::= const? aligned_modifier? type length_attribute '*'?
	identifier (assignment number_literal (range_operator number_literal)?)? semicolon

/* 6.4 Constant-length indirect representation bit fields */

/* Rule E.3: Maps */

/* Rule E.4: Mapped data types */

/* 6.5 Variable length indirect representation bit fields */

/* Rule E.5: Maps with escape codes */

output_value ::= number_literal | type length_attribute | aggregate_output_value
aggregate_output_value ::= open_brace (output_value comma)* output_value close_brace
map_entry ::= binary_literal comma aggregate_output_value

map_declaration ::= map identifier open_parenthesis (type | identifier) close_parenthesis
	open_brace (map_entry comma)+ map_entry close_brace

map_definition ::= (type | identifier) open_parenthesis identifier close_parenthesis identifier semicolon

/* 6.6 Variable length strings */

/* Rule E.6: String data types */

base64_character ::= digit_character | latin_character | '+' | '/'
base64_string_literal ::= double_quote base64_character* '='? '='? double_quote

/* 6.7 String value */

utf8_string_declaration ::= (utf8string | utfstring | utf8list) identifier (assignment utf8_string_literal)?
utf16_string_declaration ::= utfstring identifier (assignment utf16_string_literal)?
base64_string_declaration ::= base64string identifier (assignment base64_string_literal)?

string_declaration ::=  const? aligned_modifier? (base64_string_declaration | utf8_string_declaration |
	utf16_string_declaration) semicolon

/* 7.1 Classes */

/* Rule C.1: Classes */

/* Rule C.2: Class data types */

/* 7.2 Base and derived classes */

/* RULE C.3: Derived classes */

/* 7.3 Abstract classes */

/* Rule C.4: Abstract classes */

/* 7.4 Polymorphism in class declaration */

/* Rule C.5: Class polymorphism */

object_id ::= 0 | positive_integer
id_range ::= object_id range_operator object_id

bit_modifier ::= (colon bit open_parenthesis positive_integer_value close_parenthesis
	(identifier assignment)? object_id | id_range (comma (object_id | id_range))*)?

/* 7.5 Expandable classes */

/* Rule C.6: Expandable classes */

expandable_modifier ::= expandable (open_parenthesis positive_integer close_parenthesis)?

/* 7.6 Parameter types */

/* Rule C.7: Class parameter types */

parameter_list_item ::= (identifier | elementary_type) identifier
parameter_list ::= open_parenthesis (parameter_list_item comma)* parameter_list_item close_parenthesis
parameter_values ::= open_parenthesis (expression comma)* expression close_parenthesis

extends_modifier ::= extends identifier parameter_values?

class_declaration ::= aligned_modifier? expandable_modifier? abstract? class identifier
	parameter_list? extends_modifier? bit_modifier? open_brace statement* close_brace

/* Rule C.8: Parameterized class data types */

class_definition ::= identifier identifier parameter_values? semicolon

/* 7.7 Arrays */

/* Rule A.1: Arrays */

/* 7.8 Multi-dimensional arrays */

/* Rule A.2: Multi-dimensional arrays */

typespec ::= (elementary_type length_attribute) | identifier

array_element_access_expression ::= identifier (open_bracket expression close_bracket)+

/* 7.9 Partial arrays */

/* Rule A.3: Partial arrays */

/* Rule A.4: Partial multi-dimensional arrays */

array_dimension ::= open_bracket expression close_bracket
partial_array_dimension ::= open_bracket open_bracket expression close_bracket close_bracket

explicit_array_definition ::= aligned_modifier? typespec identifier (array_dimension |
	partial_array_dimension)+ semicolon

/* 7.10 Implicit arrays */

/* Rule A.5: Implicit arrays */

implicit_array_definition ::= aligned_modifier? typespec identifier open_bracket
	(positive_integer range_operator positive_integer)? close_bracket semicolon

array_definition ::= explicit_array_definition | implicit_array_definition

/* 8 Non-parsable variables */

/* 8.2 Elementary data types */

/* Rule NP.1: Elementary data types */

non_parsable_elementary_type_definition ::= const? type identifier (assignment number_literal)? semicolon

/* 8.3 Arrays */

/* Rule NP.2: Arrays */

/* 8.4 Multi-dimensional arrays */

/* Rule NP.3: Multi-dimensional arrays */

non_parsable_array_definition ::= type identifier (array_dimension)+ semicolon

/* 9 Syntactic flow control */

/* 9.1 Conditionals */

/* Rule FC.1: Flow control using if-then-else */

if_statement ::= if open_parenthesis expression close_parenthesis compound_statement (else
	if open_parenthesis expression open_parenthesis compound_statement)* (else compound_statement)*

/* Rule FC.2: Flow control using switch */

switch_case_clause ::= case constant_expression colon ((statement* break semicolon) |
	(open_brace statement* break semicolon close_brace))
switch_default_clause ::= default colon (statement* | ( open_brace statement* close_brace))

switch_statement ::= switch open_parenthesis expression close_parenthesis open_brace
	switch_case_clause* switch_default_clause? close_brace

/* 9.2 Loops */

/* Rule FC.3: Flow control using for */

for_statement ::= for open_parenthesis (assignment_expression |
	non_parsable_elementary_type_definition )? semicolon expression? semicolon
	(assignment_expression | expression)? close_parenthesis compound_statement

/* Rule FC.4: Flow control using do */

do_statement ::= do compound_statement while open_parenthesis expression close_parenthesis semicolon

/* Rule FC.5: Flow control using while */

while_statement ::= while open_parenthesis expression close_parenthesis compound_statement

